[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/v1/","content":"","keywords":""},{"title":" Effectie​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#effectie-logo-effectie","content":" Project\tMaven Centraleffectie-cats-effect3 effectie-cats-effect effectie-monix effectie-scalaz-effect\t Supported Scala Versions: 3, 2.13 and 2.12 A set of type-classes and utils for functional effect libraries (i.e. Cats Effect, Monix and Scalaz's Effect). Why Effectie? Please read &quot;Why?&quot; section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#getting-started","content":""},{"title":"For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#for-cats-effect","content":"In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies += &quot;io.kevinlee&quot; %% &quot;effectie-cats-effect&quot; % &quot;1.16.0&quot;  then import import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._  For more details, check out Effectie for Cats Effect. "},{"title":"For Monix​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#for-monix","content":"In build.sbt, libraryDependencies += &quot;io.kevinlee&quot; %% &quot;effectie-monix&quot; % &quot;1.16.0&quot;  then import import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._  For more details, check out Effectie for Monix. "},{"title":"For Scalaz Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#for-scalaz-effect","content":"In build.sbt, libraryDependencies += &quot;io.kevinlee&quot; %% &quot;effectie-scalaz-effect&quot; % &quot;1.16.0&quot;  then import import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._  For more details, check out Effectie for Scalaz Effect. "},{"title":"Why?​","type":1,"pageTitle":"Getting Started","url":"/docs/v1/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Scalaz Effect give us referential transparency. There might be an issue though with constructing an effect type data. It is actually an issue with Cats Effect as Cats Effect IO's pure (or Monad.pure) is not referentially transparent. Let's check out some code examples. e.g.) Cats Effect import cats.effect._ // or cats.Monad[IO].pure(println(&quot;a&quot;)) val io = IO.pure(println(&quot;a&quot;)) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(&quot;a&quot;) io.unsafeRunSync() io.unsafeRunSync()  e.g.) Scalaz Effect import scalaz._, scalaz.effect._ val io = Monad[IO].pure(println(&quot;a&quot;)) // io: IO[Unit] = scalaz.effect.IO$$anon$7@5d37a479 // It is referentially transparent so println(&quot;a&quot;) is not evaluated here. io.unsafePerformIO() // a io.unsafePerformIO() // a  So to have referential transparency when using Cats Effect, IO.apply() should be used. import cats.effect._ val io = IO(println(&quot;a&quot;)) // io: IO[Unit] = Delay(thunk = &lt;function0&gt;) // Now it is referentially transparent so println(&quot;a&quot;) is not evaluated here. io.unsafeRunSync() // a io.unsafeRunSync() // a  Now, let's use Cats Effect with tagless final. import cats.effect._ trait Foo[F[_]] { def get[A](a: =&gt; A): F[A] } class Bar[F[_]] extends Foo[F] { def get[A](a: =&gt; A): F[A] = // How would you construct F[A]? } // call-site val bar = new Bar[IO] bar.get(1) bar.get(println(&quot;a&quot;))  How would you construct F[A]? You could probably do Applicative[F].pure or Monad[F].pure(a). import cats._ class Bar[F[_]: Applicative] extends Foo[F] { // or [F[_]: Monad] def get[A](a: =&gt; A): F[A] = Applicative[F].pure(a) // or Monad[F].pure(a) }  However, neither Applicative.pure nor Monad.pure in Cats are referentially transparent when it's mixed with impure code (e.g. some side-effect code like println(&quot;a&quot;)). So If you do this, val bar = new Bar[IO] val iou = bar.get(println(&quot;a&quot;)) // a is printed here // and you get IO[Unit] iou.unsafeRunSync() // This does not print anything but returns ()  With Effectie you can do this. import cats.effect._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: =&gt; A): F[A] } class Bar[F[_]: Fx] extends Foo[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App9$Bar@276981ff val iou = bar.get(println(&quot;a&quot;)) // iou: IO[Unit] = Delay(thunk = &lt;function0&gt;) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a  Or a more convenient way like import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: =&gt; A): F[A] } class Bar[F[_]: Fx] extends Foo[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // no more Fx[F].effectOf } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App12$Bar@56d081c1 val iou = bar.get(println(&quot;a&quot;)) // iou: IO[Unit] = Delay(thunk = &lt;function0&gt;) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a  Check out Effectie for Cats EffectEffectie for MonixEffectie for Scalaz (v7.2.x) Effect "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/","content":"","keywords":""},{"title":"Effectie for Cats Effect​","type":1,"pageTitle":"For Cats Effect","url":"/docs/v1/docs/cats-effect/#effectie-for-cats-effect","content":"FxConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Cats Effect","url":"/docs/v1/docs/cats-effect/#all-in-one-example","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n &lt;- effectOf(a) blah &lt;- pureOf(&quot;blah blah&quot;) _ &lt;- effectOf(println(s&quot;n: $n / BLAH: $blah&quot;)) x &lt;- effectOf(n |+| n) _ &lt;- putStrLn(s&quot;x: $x&quot;) } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa &lt;- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah &lt;- &quot;blah blah&quot;.someTF[F] // OptionT(Applicative[F].pure(Some(&quot;blah blah&quot;))) _ &lt;- effectOf( println(s&quot;a: $a / BLAH: $blah&quot;) ).someT // OptionT(effectOf(Some(println(s&quot;a: $a / BLAH: $blah&quot;)))) x &lt;- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ &lt;- effectOf(putStrLn(s&quot;x: $x&quot;)).someT // OptionT(effectOf(Some(putStrLn(s&quot;x: $x&quot;)))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b &lt;- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah &lt;- &quot;blah blah&quot; .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(&quot;blah blah&quot;.asRight[A])) _ &lt;- effectOf( println(s&quot;b: $b / BLAH: $blah&quot;) ).rightT[A] // EitherT(effectOf(Right(println(s&quot;b: $b / BLAH: $blah&quot;)))) x &lt;- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ &lt;- effectOf( putStrLn(s&quot;x: $x&quot;) ).rightT[A] // EitherT(effectOf(putStrLn(s&quot;x: $x&quot;).asRight[A])) } yield x).value } } println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // Right(4) println(Something[IO].baz(&quot;ERROR!!!&quot;.asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!)  "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/can-handle-error","content":"","keywords":""},{"title":"CanHandleError​","type":1,"pageTitle":"CanHandleError","url":"/docs/v1/docs/cats-effect/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; AA ): F[AA] def handleEitherTNonFatal[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; Either[AA, BB] ): EitherT[F, AA, BB] }  There are instances available for cats.effect.IO, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal​","type":1,"pageTitle":"CanHandleError","url":"/docs/v1/docs/cats-effect/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } println(bar[IO](1).unsafeRunSync()) // 1 println(bar[IO](-1).unsafeRunSync()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0  import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0  "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/cats-effect/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- ConsoleEffect[F].putStrLn(&quot;Hello&quot;) answer &lt;- ConsoleEffect[F].readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/cats-effect/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.cats.ConsoleEffectful._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- putStrLn(&quot;Hello&quot;) answer &lt;- readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"/docs/v1/docs/cats-effect/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x &lt;- a.rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(a)) y &lt;- (x + 10).rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(x + 10)) y2 &lt;- if (y &gt; 100) &quot;Error - Bigger than 100&quot;.leftTF[F, Int] else y.rightTF[F, String] // ↑ if (y &gt; 100) // EitherT(pureOf(&quot;Error - Bigger than 100&quot;).map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z &lt;- effectOf(y2 + 100).rightT[String] // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x &lt;- a.eitherT[F] // == EitherT(pureOf(a: Either[String, Int])) y &lt;- effectOf((x + 999).asRight[String]).eitherT // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Either[String, Int] = Right(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Either[String, Int] = Right(value = 120) Something[IO].bar(1.asRight[String]).unsafeRunSync() // res3: Either[String, Int] = Right(value = 1000) Something[IO].bar(&quot;No number&quot;.asLeft[Int]).unsafeRunSync() // res4: Either[String, Int] = Left(value = &quot;No number&quot;)  "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"/docs/v1/docs/cats-effect/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for cats.effect.IOFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: =&gt; Future[A]): F[A] }  "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"/docs/v1/docs/cats-effect/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a &lt;- FromFuture[F].toEffect(foo(n)) b &lt;- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@1bfd9736[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 1, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@72d062f9 implicit val cs: ContextShift[IO] = IO.contextShift(ec) // cs: ContextShift[IO] = cats.effect.internals.IOContextShift@d73436 try { println(MyApp.baz[IO](1).unsafeRunSync()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202  "},{"title":"Fx","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/cats-effect/fx#fx","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.cats._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = &lt;function0&gt;) get1.unsafeRunSync() // res1: Int = 1  If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/cats-effect/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.cats.Effectful._ import effectie.cats._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = &lt;function0&gt;) get1.unsafeRunSync() // res3: Int = 1  "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"/docs/v1/docs/cats-effect/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x &lt;- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y &lt;- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z &lt;- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x &lt;- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y &lt;- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafeRunSync() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafeRunSync() // res4: Option[Int] = None  "},{"title":"For Monix","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/","content":"","keywords":""},{"title":"Effectie for Monix​","type":1,"pageTitle":"For Monix","url":"/docs/v1/docs/monix/#effectie-for-monix","content":"FxConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Monix","url":"/docs/v1/docs/monix/#all-in-one-example","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n &lt;- effectOf(a) blah &lt;- pureOf(&quot;blah blah&quot;) _ &lt;- effectOf(println(s&quot;n: $n / BLAH: $blah&quot;)) x &lt;- effectOf(n |+| n) _ &lt;- putStrLn(s&quot;x: $x&quot;) } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa &lt;- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah &lt;- &quot;blah blah&quot;.someTF[F] // OptionT(Applicative[F].pure(Some(&quot;blah blah&quot;))) _ &lt;- effectOf( println(s&quot;a: $a / BLAH: $blah&quot;) ).someT // OptionT(effectOf(Some(println(s&quot;a: $a / BLAH: $blah&quot;)))) x &lt;- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ &lt;- effectOf(putStrLn(s&quot;x: $x&quot;)).someT // OptionT(effectOf(Some(putStrLn(s&quot;x: $x&quot;)))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b &lt;- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah &lt;- &quot;blah blah&quot; .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(&quot;blah blah&quot;.asRight[A])) _ &lt;- effectOf( println(s&quot;b: $b / BLAH: $blah&quot;) ).rightT[A] // EitherT(effectOf(Right(println(s&quot;b: $b / BLAH: $blah&quot;)))) x &lt;- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ &lt;- effectOf( putStrLn(s&quot;x: $x&quot;) ).rightT[A] // EitherT(effectOf(putStrLn(s&quot;x: $x&quot;).asRight[A])) } yield x).value } } import monix.execution.Scheduler.Implicits.global println(Something[Task].foo(1).runSyncUnsafe()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[Task].bar(2.some).runSyncUnsafe()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[Task].bar(none[String]).runSyncUnsafe()) // None println(Something[Task].baz(2.asRight[String]).runSyncUnsafe()) // b: 2 / BLAH: blah blah // Right(4) println(Something[Task].baz(&quot;ERROR!!!&quot;.asLeft[Int]).runSyncUnsafe()) // Left(ERROR!!!)  "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"/docs/v1/docs/cats-effect/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: =&gt; F[B])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: =&gt; F[Either[A, B]])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: =&gt; EitherT[F, A, B])(f: Throwable =&gt; A): EitherT[F, A, B] }  "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(&quot;Something's wrong!&quot;)) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@58d0245d, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) fa.unsafeRunSync() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:117), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App6$.doSomething(can-catch.md:120), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:123), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:74), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:57), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:25), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:317), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App12$.doSomething(can-catch.md:320), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:323), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:274), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:217), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:137), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:74), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:57), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:25), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(Markd... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use-1","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@698d1f01, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@6dffc430, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:597), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App24$.doSomething(can-catch.md:600), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:603), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // repl.MdocSession$App20$.&lt;clinit&gt;(can-catch.md:526), // repl.MdocSession$App18$.&lt;clinit&gt;(can-catch.md:494), // repl.MdocSession$App16$.&lt;clinit&gt;(can-catch.md:474), // repl.MdocSession$App14$.&lt;clinit&gt;(can-catch.md:417), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:337), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:274), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:217), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:137), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:74), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:57), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:25), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:829), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App30$.doSomething(can-catch.md:832), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:835), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // repl.MdocSession$App20$.&lt;clinit&gt;(can-catch.md:526), // repl.MdocSession$App18$.&lt;clinit&gt;(can-catch.md:494), // repl.MdocSession$App16$.&lt;clinit&gt;(can-catch.md:474), // repl.MdocSession$App14$.&lt;clinit&gt;(can-catch.md:417), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:337), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:274), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:217), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:137), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:74), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:57), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:25), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use-2","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@7158e79a, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@621563c5, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // ... fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example-2","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@33e06a7a, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1154), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.EitherTSupport._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@7a223c88, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1154), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use-3","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatal( IO(throw new RuntimeException(&quot;Something's wrong!&quot;)) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@5b15a5cd, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) fa.unsafeRunSync() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1703), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1706), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1709), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1657), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1640), // repl.MdocSession$App54$.&lt;clinit&gt;(can-catch.md:1608), // repl.MdocSession$App52$.&lt;clinit&gt;(can-catch.md:1588), // repl.MdocSession$App50$.&lt;clinit&gt;(can-catch.md:1514), // repl.MdocSession$App48$.&lt;clinit&gt;(can-catch.md:1418), // repl.MdocSession$App46$.&lt;clinit&gt;(can-catch.md:1338), // repl.MdocSession$App44$.&lt;clinit&gt;(can-catch.md:1264), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1168), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // repl.MdocSession$App20$.&lt;clinit&gt;(can-catch.md:526), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1913), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1916), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1919), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1867), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1807), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1723), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1657), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1640), // repl.MdocSession$App54$.&lt;clinit&gt;(can-catch.md:1608), // repl.MdocSession$App52$.&lt;clinit&gt;(can-catch.md:1588), // repl.MdocSession$App50$.&lt;clinit&gt;(can-catch.md:1514), // repl.MdocSession$App48$.&lt;clinit&gt;(can-catch.md:1418), // repl.MdocSession$App46$.&lt;clinit&gt;(can-catch.md:1338), // repl.MdocSession$App44$.&lt;clinit&gt;(can-catch.md:1264), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1168), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use-4","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@1456c3db, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@621b3751, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... fa.unsafeRunSync() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2202), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2205), // repl.MdocSession$App78$.&lt;clinit&gt;(can-catch.md:2208), // repl.MdocSession$App76$.&lt;clinit&gt;(can-catch.md:2145), // repl.MdocSession$App74$.&lt;clinit&gt;(can-catch.md:2128), // repl.MdocSession$App72$.&lt;clinit&gt;(can-catch.md:2096), // repl.MdocSession$App70$.&lt;clinit&gt;(can-catch.md:2076), // repl.MdocSession$App68$.&lt;clinit&gt;(can-catch.md:2016), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1933), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1867), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1807), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1723), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1657), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1640), // repl.MdocSession$App54$.&lt;clinit&gt;(can-catch.md:1608), // repl.MdocSession$App52$.&lt;clinit&gt;(can-catch.md:1588), // repl.MdocSession$App50$.&lt;clinit&gt;(can-catch.md:1514), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2443), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2446), // repl.MdocSession$App84$.&lt;clinit&gt;(can-catch.md:2449), // repl.MdocSession$App82$.&lt;clinit&gt;(can-catch.md:2386), // repl.MdocSession$App80$.&lt;clinit&gt;(can-catch.md:2315), // repl.MdocSession$App78$.&lt;clinit&gt;(can-catch.md:2222), // repl.MdocSession$App76$.&lt;clinit&gt;(can-catch.md:2145), // repl.MdocSession$App74$.&lt;clinit&gt;(can-catch.md:2128), // repl.MdocSession$App72$.&lt;clinit&gt;(can-catch.md:2096), // repl.MdocSession$App70$.&lt;clinit&gt;(can-catch.md:2076), // repl.MdocSession$App68$.&lt;clinit&gt;(can-catch.md:2016), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1933), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1867), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1807), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1723), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1657), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1640), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#how-to-use-5","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@68db1698, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@53c1056d, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // ... fa.value.unsafeRunSync() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#happy-path-example-5","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@aa9aeea, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1154), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/cats-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@519838bf, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1154), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1088), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1065), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1030), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1007), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:939), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:849), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:775), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:707), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:617), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/can-handle-error","content":"","keywords":""},{"title":"CanHandleError​","type":1,"pageTitle":"CanHandleError","url":"/docs/v1/docs/monix/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; AA ): F[AA] def handleEitherTNonFatal[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; Either[AA, BB] ): EitherT[F, AA, BB] }  There are instances available for monix.eval.Task, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal​","type":1,"pageTitle":"CanHandleError","url":"/docs/v1/docs/monix/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } import monix.execution.Scheduler.Implicits.global println(bar[Task](1).runSyncUnsafe()) // 1 println(bar[Task](-1).runSyncUnsafe()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0  import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0  "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/monix/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- ConsoleEffect[F].putStrLn(&quot;Hello&quot;) answer &lt;- ConsoleEffect[F].readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- ConsoleEffect[F].putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/monix/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.monix.ConsoleEffectful._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- putStrLn(&quot;Hello&quot;) answer &lt;- readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"/docs/v1/docs/monix/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x &lt;- a.rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(a)) y &lt;- (x + 10).rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(x + 10)) y2 &lt;- if (y &gt; 100) &quot;Error - Bigger than 100&quot;.leftTF[F, Int] else y.rightTF[F, String] // ↑ if (y &gt; 100) // EitherT(pureOf(&quot;Error - Bigger than 100&quot;).map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z &lt;- effectOf(y2 + 100).rightT[String] // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x &lt;- a.eitherT[F] // == EitherT(pureOf(a: Either[String, Int])) y &lt;- effectOf((x + 999).asRight[String]).eitherT // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Either[String, Int] = Right(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Either[String, Int] = Right(value = 120) Something[Task].bar(1.asRight[String]).runSyncUnsafe() // res3: Either[String, Int] = Right(value = 1000) Something[Task].bar(&quot;No number&quot;.asLeft[Int]).runSyncUnsafe() // res4: Either[String, Int] = Left(value = &quot;No number&quot;)  "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"/docs/v1/docs/monix/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for monix.eval.TaskFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: =&gt; Future[A]): F[A] }  "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"/docs/v1/docs/monix/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a &lt;- FromFuture[F].toEffect(foo(n)) b &lt;- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@4f43847a[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@4299e797 import monix.execution.Scheduler.Implicits.global try { println(MyApp.baz[Task](1).runSyncUnsafe()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202  "},{"title":"Fx","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/monix/fx#fx","content":"If you use Monix and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.monix._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = &lt;function0&gt;) get1.runSyncUnsafe() // res1: Int = 1  If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/monix/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.monix.Effectful._ import effectie.monix._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = &lt;function0&gt;) get1.runSyncUnsafe() // res3: Int = 1  "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"/docs/v1/docs/monix/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x &lt;- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y &lt;- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z &lt;- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x &lt;- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y &lt;- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Option[Int] = Some(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Option[Int] = Some(value = 120) Something[Task].bar(1.some).runSyncUnsafe() // res3: Option[Int] = Some(value = 1000) Something[Task].bar(none[Int]).runSyncUnsafe() // res4: Option[Int] = None  "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"/docs/v1/docs/monix/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: =&gt; F[B])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: =&gt; F[Either[A, B]])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: =&gt; EitherT[F, A, B])(f: Throwable =&gt; A): EitherT[F, A, B] }  "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatal( Task(throw new RuntimeException(&quot;Something's wrong!&quot;)) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@713153c9, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:120), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App6$.doSomething(can-catch.md:123), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:126), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:77), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:60), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:28), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(Markd... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:323), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App12$.doSomething(can-catch.md:326), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:329), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:280), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:223), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:143), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:77), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:60), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:28), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use-1","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEither( Task((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@10c89077, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@6b9c26bc, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:609), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App24$.doSomething(can-catch.md:612), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:615), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:555), // repl.MdocSession$App20$.&lt;clinit&gt;(can-catch.md:538), // repl.MdocSession$App18$.&lt;clinit&gt;(can-catch.md:506), // repl.MdocSession$App16$.&lt;clinit&gt;(can-catch.md:483), // repl.MdocSession$App14$.&lt;clinit&gt;(can-catch.md:426), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:346), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:280), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:223), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:143), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:77), // repl.MdocSession$App2$.&lt;clinit&gt;(can-catch.md:60), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:28), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:844), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App30$.doSomething(can-catch.md:847), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:850), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:722), // repl.MdocSession$App24$.&lt;clinit&gt;(can-catch.md:632), // repl.MdocSession$App22$.&lt;clinit&gt;(can-catch.md:555), // repl.MdocSession$App20$.&lt;clinit&gt;(can-catch.md:538), // repl.MdocSession$App18$.&lt;clinit&gt;(can-catch.md:506), // repl.MdocSession$App16$.&lt;clinit&gt;(can-catch.md:483), // repl.MdocSession$App14$.&lt;clinit&gt;(can-catch.md:426), // repl.MdocSession$App12$.&lt;clinit&gt;(can-catch.md:346), // repl.MdocSession$App10$.&lt;clinit&gt;(can-catch.md:280), // repl.MdocSession$App8$.&lt;clinit&gt;(can-catch.md:223), // repl.MdocSession$App6$.&lt;clinit&gt;(can-catch.md:143), // repl.MdocSession$App4$.&lt;clinit&gt;(can-catch.md:77), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use-2","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEitherT( EitherT(Task((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@6c8dfa95, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@662e887e, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example-2","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@590faca1, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1175), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:867), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example-2","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.EitherTSupport._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@4bf0a286, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1175), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:867), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use-3","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatal( Task(throw new RuntimeException(&quot;Something's wrong!&quot;)) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@5530b5d1, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ) import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1733), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1736), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1739), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1687), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1670), // repl.MdocSession$App54$.&lt;clinit&gt;(can-catch.md:1638), // repl.MdocSession$App52$.&lt;clinit&gt;(can-catch.md:1615), // repl.MdocSession$App50$.&lt;clinit&gt;(can-catch.md:1541), // repl.MdocSession$App48$.&lt;clinit&gt;(can-catch.md:1445), // repl.MdocSession$App46$.&lt;clinit&gt;(can-catch.md:1362), // repl.MdocSession$App44$.&lt;clinit&gt;(can-catch.md:1288), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1192), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:867), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // repl.MdocSession$App26$.&lt;clinit&gt;(can-catch.md:722), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1946), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1949), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1952), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1900), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1840), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1756), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1687), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1670), // repl.MdocSession$App54$.&lt;clinit&gt;(can-catch.md:1638), // repl.MdocSession$App52$.&lt;clinit&gt;(can-catch.md:1615), // repl.MdocSession$App50$.&lt;clinit&gt;(can-catch.md:1541), // repl.MdocSession$App48$.&lt;clinit&gt;(can-catch.md:1445), // repl.MdocSession$App46$.&lt;clinit&gt;(can-catch.md:1362), // repl.MdocSession$App44$.&lt;clinit&gt;(can-catch.md:1288), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1192), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use-4","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEither( Task((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@4897fb8f, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@18595171, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2241), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2244), // repl.MdocSession$App78$.&lt;clinit&gt;(can-catch.md:2247), // repl.MdocSession$App76$.&lt;clinit&gt;(can-catch.md:2184), // repl.MdocSession$App74$.&lt;clinit&gt;(can-catch.md:2167), // repl.MdocSession$App72$.&lt;clinit&gt;(can-catch.md:2135), // repl.MdocSession$App70$.&lt;clinit&gt;(can-catch.md:2112), // repl.MdocSession$App68$.&lt;clinit&gt;(can-catch.md:2052), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1969), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1900), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1840), // repl.MdocSession$App60$.&lt;clinit&gt;(can-catch.md:1756), // repl.MdocSession$App58$.&lt;clinit&gt;(can-catch.md:1687), // repl.MdocSession$App56$.&lt;clinit&gt;(can-catch.md:1670), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = &lt;function1&gt;, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2485), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2488), // repl.MdocSession$App84$.&lt;clinit&gt;(can-catch.md:2491), // repl.MdocSession$App82$.&lt;clinit&gt;(can-catch.md:2428), // repl.MdocSession$App80$.&lt;clinit&gt;(can-catch.md:2357), // repl.MdocSession$App78$.&lt;clinit&gt;(can-catch.md:2264), // repl.MdocSession$App76$.&lt;clinit&gt;(can-catch.md:2184), // repl.MdocSession$App74$.&lt;clinit&gt;(can-catch.md:2167), // repl.MdocSession$App72$.&lt;clinit&gt;(can-catch.md:2135), // repl.MdocSession$App70$.&lt;clinit&gt;(can-catch.md:2112), // repl.MdocSession$App68$.&lt;clinit&gt;(can-catch.md:2052), // repl.MdocSession$App66$.&lt;clinit&gt;(can-catch.md:1969), // repl.MdocSession$App64$.&lt;clinit&gt;(can-catch.md:1900), // repl.MdocSession$App62$.&lt;clinit&gt;(can-catch.md:1840), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#how-to-use-5","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEitherT[Task]( EitherT(Task((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = &lt;function0&gt;), // f = &lt;function1&gt;, // trace = null // ), // f = effectie.CanCatch$$Lambda$11873/0x0000000103512040@3dab99e8, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.&lt;clinit&gt;(can-catch.md:19), // repl.MdocSession$App.&lt;init&gt;(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:104) // ) // ) // ), // f = effectie.CanCatch$$Lambda$11888/0x000000010352d840@6fab95f5, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#happy-path-example-5","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@9e1ed9f, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1175), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:867), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/monix/can-catch#unhappy-path-example-5","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$11890/0x000000010352c840@3a56d56b, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.&lt;clinit&gt;(can-catch.md:1175), // repl.MdocSession$App40$.&lt;clinit&gt;(can-catch.md:1109), // repl.MdocSession$App38$.&lt;clinit&gt;(can-catch.md:1086), // repl.MdocSession$App36$.&lt;clinit&gt;(can-catch.md:1051), // repl.MdocSession$App34$.&lt;clinit&gt;(can-catch.md:1025), // repl.MdocSession$App32$.&lt;clinit&gt;(can-catch.md:957), // repl.MdocSession$App30$.&lt;clinit&gt;(can-catch.md:867), // repl.MdocSession$App28$.&lt;clinit&gt;(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/","content":"","keywords":""},{"title":"Effectie for Scalaz Effect​","type":1,"pageTitle":"For Scalaz Effect","url":"/docs/v1/docs/scalaz-effect/#effectie-for-scalaz-effect","content":"FxConsoleEffectOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Scalaz Effect","url":"/docs/v1/docs/scalaz-effect/#all-in-one-example","content":"import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A: Semigroup, B: Semigroup](a: A \\/ B): F[A \\/ B] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n &lt;- effectOf(a) blah &lt;- pureOf(&quot;blah blah&quot;) _ &lt;- effectOf(println(s&quot;n: $n / BLAH: $blah&quot;)) x &lt;- effectOf(n |+| n) _ &lt;- putStrLn(s&quot;x: $x&quot;) } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa &lt;- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah &lt;- &quot;blah blah&quot;.someTF[F] // OptionT(Applicative[F].pure(Some(&quot;blah blah&quot;))) _ &lt;- effectOf( println(s&quot;a: $a / BLAH: $blah&quot;) ).someT // OptionT(effectOf(Some(println(s&quot;a: $a / BLAH: $blah&quot;)))) x &lt;- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ &lt;- effectOf(putStrLn(s&quot;x: $x&quot;)).someT // OptionT(effectOf(Some(putStrLn(s&quot;x: $x&quot;)))) } yield x).run override def baz[A: Semigroup, B: Semigroup](ab: A \\/ B): F[A \\/ B] = (for { b &lt;- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah &lt;- &quot;blah blah&quot; .right[A] .eitherT[F] // EitherT(Applicative[F].pure(&quot;blah blah&quot;.right[A])) _ &lt;- effectOf( println(s&quot;b: $b / BLAH: $blah&quot;) ).rightT[A] // EitherT(effectOf(\\/-(println(s&quot;b: $b / BLAH: $blah&quot;)))) x &lt;- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ &lt;- effectOf( putStrLn(s&quot;x: $x&quot;) ).rightT[A] // EitherT(effectOf(putStrLn(s&quot;x: $x&quot;).right[A])) } yield x).run } } println(Something[IO].foo(1).unsafePerformIO()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafePerformIO()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[IO].bar(none[String]).unsafePerformIO()) // None println(Something[IO].baz(2.right[String]).unsafePerformIO()) // b: 2 / BLAH: blah blah // \\/-(4) println(Something[IO].baz(&quot;ERROR!!!&quot;.left[Int]).unsafePerformIO()) // -\\/(ERROR!!!)  "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/scalaz-effect/console-effect#consoleeffect","content":"import scalaz._ import Scalaz._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- ConsoleEffect[F].putStrLn(&quot;Hello&quot;) answer &lt;- ConsoleEffect[F].readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- ConsoleEffect[F].putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/v1/docs/scalaz-effect/console-effect#consoleeffectful","content":"import scalaz._ import Scalaz._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- putStrLn(&quot;Hello&quot;) answer &lt;- readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"/docs/v1/docs/scalaz-effect/eithert-support#eithertsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[String \\/ Int] def bar(a: String \\/ Int): F[String \\/ Int] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[String \\/ Int] = (for { x &lt;- a.rightTF[F, String] // == EitherT(Applicative[F].pure(a).map(_.right[String])) y &lt;- (x + 10).rightTF[F, String] // == EitherT(Applicative[F].pure(x + 10).map(_.right[String])) y2 &lt;- if (y &gt; 100) eitherTLeft[Int](&quot;Error - Bigger than 100&quot;) else eitherTRightPure[String](y) // ↑ if (y &gt; 100) // EitherT(pureOF(&quot;Error - Bigger than 100&quot;).map(_.left[Int])) // else // EitherT(pureOf(y).map(_.right[String])) z &lt;- effectOf(y2 + 100).rightT[String] // == EitherT(effectOf(y + 100).map(_.right)) } yield z).run def bar(a: String \\/ Int): F[String \\/ Int] = (for { x &lt;- a.eitherT[F] // == EitherT(pureOf(a: String \\/ Int)) y &lt;- effectOf((x + 999).right[String]).eitherT // == EitherT(effectOf((x + 999).right[String])) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: String \\/ Int = \\/-(b = 111) Something[IO].foo(10).unsafePerformIO() // res2: String \\/ Int = \\/-(b = 120) Something[IO].bar(1.right[String]).unsafePerformIO() // res3: String \\/ Int = \\/-(b = 1000) Something[IO].bar(&quot;No number&quot;.left[Int]).unsafePerformIO() // res4: String \\/ Int = -\\/(a = &quot;No number&quot;)  "},{"title":"Fx","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/scalaz-effect/fx#fx","content":"If you use Scalaz Effect and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.scalaz._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@8502d8a get1.unsafePerformIO() // res1: Int = 1  If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"/docs/v1/docs/scalaz-effect/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.scalaz.Effectful._ import effectie.scalaz._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@63a23ce get1.unsafePerformIO() // res3: Int = 1  "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"/docs/v1/docs/scalaz-effect/optiont-support#optiontsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x &lt;- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y &lt;- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z &lt;- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).run def bar(a: Option[Int]): F[Option[Int]] = (for { x &lt;- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y &lt;- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafePerformIO() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafePerformIO() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafePerformIO() // res4: Option[Int] = None  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/","content":"","keywords":""},{"title":" Effectie​","type":1,"pageTitle":"Getting Started","url":"/docs/#effectie-logo-effectie","content":" Project\tMaven Centraleffectie-cats-effect3 effectie-cats-effect2 effectie-monix3\t Supported Scala Versions: 3, 2.13 and 2.12 A set of type-classes and utils for functional effect libraries (i.e. Cats Effect, Monix and Scalaz's Effect). Why Effectie? Please read &quot;Why?&quot; section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"/docs/#getting-started","content":""},{"title":"For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"/docs/#for-cats-effect","content":"In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies += &quot;io.kevinlee&quot; %% &quot;effectie-cats-effect2&quot; % &quot;2.0.0-beta5&quot;  For more details, check out Effectie for Cats Effect. "},{"title":"For Monix​","type":1,"pageTitle":"Getting Started","url":"/docs/#for-monix","content":"In build.sbt, libraryDependencies += &quot;io.kevinlee&quot; %% &quot;effectie-monix&quot; % &quot;2.0.0-beta5&quot;  For more details, check out Effectie for Monix. "},{"title":"Why?​","type":1,"pageTitle":"Getting Started","url":"/docs/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Monix give us referential transparency (and more). There might be an issue though with writing implementation for the abstraction which is supposed to support not only effect libraries like Cats Effect but also Future. You may end up writing exactly the same code with only exception of how you construct effect data type (e.g. IO vs Future). Let's check out some code examples. e.g.) Cats Effect import cats.effect._ // or cats.Monad[IO].pure(println(&quot;a&quot;)) val io = IO.pure(println(&quot;a&quot;)) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(&quot;a&quot;) io.unsafeRunSync() io.unsafeRunSync()  e.g.) Future WIP... Check out Effectie for Cats Effect 2Effectie for Monix 3 "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"/docs/cats-effect2/","content":"","keywords":""},{"title":"Effectie for Cats Effect​","type":1,"pageTitle":"For Cats Effect","url":"/docs/cats-effect2/#effectie-for-cats-effect","content":"FxConsoleEffectCanCatchCanHandleErrorFromFuture "},{"title":"All in One Example​","type":1,"pageTitle":"For Cats Effect","url":"/docs/cats-effect2/#all-in-one-example","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.cats.syntax.all._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n &lt;- effectOf(a) blah &lt;- pureOf(&quot;blah blah&quot;) _ &lt;- effectOf(println(s&quot;n: $n / BLAH: $blah&quot;)) x &lt;- effectOf(n |+| n) _ &lt;- putStrLn(s&quot;x: $x&quot;) } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa &lt;- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah &lt;- &quot;blah blah&quot;.someTF[F] // OptionT(Applicative[F].pure(Some(&quot;blah blah&quot;))) _ &lt;- effectOf( println(s&quot;a: $a / BLAH: $blah&quot;) ).someT // OptionT(effectOf(Some(println(s&quot;a: $a / BLAH: $blah&quot;)))) x &lt;- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ &lt;- effectOf(putStrLn(s&quot;x: $x&quot;)).someT // OptionT(effectOf(Some(putStrLn(s&quot;x: $x&quot;)))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b &lt;- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah &lt;- &quot;blah blah&quot; .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(&quot;blah blah&quot;.asRight[A])) _ &lt;- effectOf( println(s&quot;b: $b / BLAH: $blah&quot;) ).rightT[A] // EitherT(effectOf(Right(println(s&quot;b: $b / BLAH: $blah&quot;)))) x &lt;- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ &lt;- effectOf( putStrLn(s&quot;x: $x&quot;) ).rightT[A] // EitherT(effectOf(putStrLn(s&quot;x: $x&quot;).asRight[A])) } yield x).value } } import effectie.instances.ce2.fx._ import effectie.instances.console._ println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // Right(4) println(Something[IO].baz(&quot;ERROR!!!&quot;.asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!)  "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"/docs/v1/docs/scalaz-effect/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: =&gt; F[B])(f: Throwable =&gt; A): F[A \\/ B] def catchNonFatalEither[A, B](fab: =&gt; F[A \\/ B])(f: Throwable =&gt; A): F[A \\/ B] def catchNonFatalEitherT[A, B](fab: =&gt; EitherT[F, A, B])(f: Throwable =&gt; A): EitherT[F, A, B] }  "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use","content":"IOFutureId import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(&quot;Something's wrong!&quot;)) )(identity) // fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@644a8588 fa.unsafePerformIO() // res1: scalaz.\\/[Throwable, Nothing] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@26088823 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@165e3faf val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[A \\/ B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use-1","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@426bdf20 fa.unsafePerformIO() // res19: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@481ffb8f val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@5491af73 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use-2","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@1ffec3b2 // ) fa.run.unsafePerformIO() // res37: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6413e8d val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6f4b8ea4 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use-3","content":"IOFutureId import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatal( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Int) )(identity) // fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@3239c10b fa.unsafePerformIO() // res55: scalaz.\\/[Throwable, Int] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@4675460d val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@3a38f651 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[A \\/ B] and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use-4","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@51b06e51 fa.unsafePerformIO() // res73: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@73e0c34e val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2170e985 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#how-to-use-5","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@31503405 // ) fa.run.unsafePerformIO() // res91: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#happy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@555014aa val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/v1/docs/scalaz-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@6590e219 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) =&gt; println(s&quot;Result is $b&quot;) case -\\/(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"/docs/cats-effect2/can-handle-error","content":"","keywords":""},{"title":"CanHandleError​","type":1,"pageTitle":"CanHandleError","url":"/docs/cats-effect2/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA &gt;: A]( fa: =&gt; F[A] )( handleError: Throwable =&gt; AA ): F[AA] def handleEitherTNonFatal[A, AA &gt;: A, B, BB &gt;: B]( efab: =&gt; EitherT[F, A, B] )( handleError: Throwable =&gt; Either[AA, BB] ): EitherT[F, AA, BB] }  There are instances available for cats.effect.IO, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal​","type":1,"pageTitle":"CanHandleError","url":"/docs/cats-effect2/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } import effectie.instances.ce2.fx._ println(bar[IO](1).unsafeRunSync()) // 1 println(bar[IO](-1).unsafeRunSync()) // 0 import effectie.instances.id.fx._ println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0  import effectie.core._ import effectie.syntax.all._ import scala.util.control.NonFatal import extras.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n &lt; 0) throw new InvalidNumberException(n, s&quot;n cannot be a negative Int. n: $n&quot;) else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) =&gt; pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { import effectie.instances.future.fx._ println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0  "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"/docs/cats-effect2/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/cats-effect2/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.core._ import effectie.core.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- ConsoleEffect[F].putStrLn(&quot;Hello&quot;) answer &lt;- ConsoleEffect[F].readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ import effectie.instances.ce2.fx._ import effectie.instances.console._ val foo = Something[IO].foo() foo.unsafeRunSync()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"/docs/cats-effect2/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.cats.ConsoleEffectful._ import effectie.core._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ &lt;- putStrLn(&quot;Hello&quot;) answer &lt;- readYesNo(&quot;Would you like to proceed?&quot;) result = answer match { case YesNo.Yes =&gt; &quot;Done&quot; case YesNo.No =&gt; &quot;Cancelled&quot; } _ &lt;- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync()  Hello Would you like to proceed? n Cancelled  Hello Would you like to proceed? y Done  "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"/docs/cats-effect2/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"/docs/cats-effect2/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for cats.effect.IOFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: =&gt; Future[A]): F[A] }  "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"/docs/cats-effect2/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a &lt;- FromFuture[F].toEffect(foo(n)) b &lt;- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@13b1bc1a[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 1, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@7411eb08 implicit val cs: ContextShift[IO] = IO.contextShift(ec) // cs: ContextShift[IO] = cats.effect.internals.IOContextShift@bcdf65e try { import effectie.instances.ce2.fx._ import effectie.instances.ce2.fromFuture._ println(MyApp.baz[IO](1).unsafeRunSync()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202  "},{"title":"Fx","type":0,"sectionRef":"#","url":"/docs/cats-effect2/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"/docs/cats-effect2/fx#fx","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.core._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } } import cats.effect._ import effectie.instances.ce2.fx._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay( // thunk = &lt;function0&gt;, // trace = StackTrace( // ... get1.unsafeRunSync() // res1: Int = 1  If you feel it's too cumbersome to repeat Fx[F].effectOf(), use effectie.syntax.all._. "},{"title":"Syntax​","type":1,"pageTitle":"Fx","url":"/docs/cats-effect2/fx#syntax","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use effectie.syntax instead. import effectie.core._ import effectie.syntax.all._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import cats.effect._ import effectie.instances.ce2.fx._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay( // thunk = &lt;function0&gt;, // trace = StackTrace( // ... get1.unsafeRunSync() // res3: Int = 1  "},{"title":"For Monix","type":0,"sectionRef":"#","url":"/docs/monix3/","content":"","keywords":""},{"title":"Effectie for Monix​","type":1,"pageTitle":"For Monix","url":"/docs/monix3/#effectie-for-monix","content":"FxFromFuture "},{"title":"All in One Example​","type":1,"pageTitle":"For Monix","url":"/docs/monix3/#all-in-one-example","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.syntax.all._ import extras.cats.syntax.all._ import effectie.core._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n &lt;- effectOf(a) blah &lt;- pureOf(&quot;blah blah&quot;) _ &lt;- effectOf(println(s&quot;n: $n / BLAH: $blah&quot;)) x &lt;- effectOf(n |+| n) _ &lt;- putStrLn(s&quot;x: $x&quot;) } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa &lt;- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah &lt;- &quot;blah blah&quot;.someTF[F] // OptionT(Applicative[F].pure(Some(&quot;blah blah&quot;))) _ &lt;- effectOf( println(s&quot;a: $a / BLAH: $blah&quot;) ).someT // OptionT(effectOf(Some(println(s&quot;a: $a / BLAH: $blah&quot;)))) x &lt;- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ &lt;- effectOf(putStrLn(s&quot;x: $x&quot;)).someT // OptionT(effectOf(Some(putStrLn(s&quot;x: $x&quot;)))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b &lt;- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah &lt;- &quot;blah blah&quot; .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(&quot;blah blah&quot;.asRight[A])) _ &lt;- effectOf( println(s&quot;b: $b / BLAH: $blah&quot;) ).rightT[A] // EitherT(effectOf(Right(println(s&quot;b: $b / BLAH: $blah&quot;)))) x &lt;- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ &lt;- effectOf( putStrLn(s&quot;x: $x&quot;) ).rightT[A] // EitherT(effectOf(putStrLn(s&quot;x: $x&quot;).asRight[A])) } yield x).value } } import monix.execution.Scheduler.Implicits.global import effectie.instances.monix3.fx._ import effectie.instances.console._ println(Something[Task].foo(1).runSyncUnsafe()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[Task].bar(2.some).runSyncUnsafe()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[Task].bar(none[String]).runSyncUnsafe()) // None println(Something[Task].baz(2.asRight[String]).runSyncUnsafe()) // b: 2 / BLAH: blah blah // Right(4) println(Something[Task].baz(&quot;ERROR!!!&quot;.asLeft[Int]).runSyncUnsafe()) // Left(ERROR!!!)  "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"/docs/monix3/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"/docs/monix3/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for monix.eval.TaskFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: =&gt; Future[A]): F[A] }  "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"/docs/monix3/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.core._ import effectie.syntax.all._ import extras.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a &lt;- FromFuture[F].toEffect(foo(n)) b &lt;- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() &gt;&gt; 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@1bce2e33[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@4e457968 import monix.execution.Scheduler.Implicits.global try { import effectie.instances.monix3.fx._ import effectie.instances.monix3.fromFuture._ println(MyApp.baz[Task](1).runSyncUnsafe()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202  "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"/docs/cats-effect2/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: =&gt; F[B])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: =&gt; F[Either[A, B]])(f: Throwable =&gt; A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: =&gt; EitherT[F, A, B])(f: Throwable =&gt; A): EitherT[F, A, B] }  "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use","content":"IOFutureId import cats.effect._ import effectie.core._ import effectie.instances.ce2.fx._ final case class MyException(cause: Throwable) extends RuntimeException val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(&quot;Something's wrong!&quot;)) ) { case ex =&gt; MyException(ex) } // fa: IO[Either[MyException, Nothing]] = Bind( // source = Bind( // source = Delay( // ... fa.unsafeRunSync() // res1: Either[MyException, Nothing] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b ) { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b ) { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use-1","content":"IOFutureId import cats.effect._ import effectie.core._ import effectie.instances.ce2.fx._ final case class MyException(cause: Throwable) extends RuntimeException val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) ) { case ex =&gt; MyException(ex) } // fa: IO[Either[Throwable, Int]] = Bind( // source = Bind( // source = Delay( // ... fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c ) { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c ) { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use-2","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.core._ import effectie.syntax.all._ import effectie.instances.ce2.fx._ final case class MyException(cause: Throwable) extends RuntimeException val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) ) { case ex =&gt; MyException(ex) } // fa: EitherT[[α$0$]IO[α$0$], Throwable, Int] = EitherT( // value = Bind( // source = Bind( // ... fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example-2","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.cats.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- pureOf(divide100By(n)).eitherT c &lt;- doSomethingBad(b).rightTF[F, MyError] } yield c ) { case ex =&gt; MyError.nonFatalThrowable(ex) }.value import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example-2","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.cats.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b &lt;- pureOf(divide100By(n)).eitherT c &lt;- doSomethingBad(b).rightTF[F, MyError] } yield c ) { case ex =&gt; MyError.nonFatalThrowable(ex) }.value import effectie.instances.ce2.fx._ val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use-3","content":"IOFutureId import cats.effect._ import effectie.syntax.all._ final case class MyException(cause: Throwable) extends RuntimeException import effectie.instances.ce2.fx._ val fa = IO(throw new RuntimeException(&quot;Something's wrong!&quot;)) .catchNonFatal { case ex =&gt; MyException(ex) } // fa: IO[Either[MyException, Nothing]] = Bind( // source = Bind( // source = Delay( // ... fa.unsafeRunSync() // res55: Either[MyException, Nothing] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b) .catchNonFatal { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 202  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { a &lt;- pureOf(n + 100) b &lt;- effectOf(doSomethingBad(a)) } yield b) .catchNonFatal { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(MyError.NonFatalThrowable(a)) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]  "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use-4","content":"IOFutureId import cats.effect._ import effectie.syntax.all._ final case class MyException(cause: Throwable) extends RuntimeException import effectie.instances.ce2.fx._ val fa = IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int]) .catchNonFatalEither { case ex =&gt; MyException(ex) } // fa: IO[Either[Throwable, Int]] = Bind( // source = Bind( // source = Delay( // ... fa.unsafeRunSync() // res72: Either[Throwable, Int] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c) .catchNonFatalEither { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { aOrB &lt;- pureOf(divide100By(n)) c &lt;- effectOf(aOrB.map(b =&gt; doSomethingBad(b))) } yield c) .catchNonFatalEither { case ex =&gt; MyError.nonFatalThrowable(ex) } import effectie.instances.ce2.fx._ val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#how-to-use-5","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.syntax.all._ final case class MyException(cause: Throwable) extends RuntimeException import effectie.instances.ce2.fx._ val fa = EitherT(IO((throw new RuntimeException(&quot;Something's wrong!&quot;)): Either[Throwable, Int])) .catchNonFatalEitherT { case ex =&gt; MyException(ex) } // fa: EitherT[[A]IO[A], Throwable, Int] = EitherT( // value = Bind( // source = Bind( // ... fa.value.unsafeRunSync() // res89: Either[Throwable, Int] = Left( // value = MyException(cause = java.lang.RuntimeException: Something's wrong!) // )  "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#happy-path-example-5","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.cats.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- doSomethingBad(b).rightTF[F, MyError] } yield c) .catchNonFatalEitherT { case ex =&gt; MyError.nonFatalThrowable(ex) }.value import effectie.instances.ce2.fx._ val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result is 200  "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"/docs/cats-effect2/can-catch#unhappy-path-example-5","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.core._ import effectie.syntax.all._ import extras.cats.syntax.all._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n &lt; 0) throw new IllegalArgumentException(s&quot;n cannot be a negative number. [n: $n]&quot;) else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = (for { b &lt;- EitherT(pureOf(divide100By(n))) c &lt;- doSomethingBad(b).rightTF[F, MyError] } yield c) .catchNonFatalEitherT { case ex =&gt; MyError.nonFatalThrowable(ex) }.value import effectie.instances.ce2.fx._ val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Bind( // source = Bind( // source = Bind( // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe... result match { case Right(b) =&gt; println(s&quot;Result is $b&quot;) case Left(a) =&gt; println(s&quot;Result: Failed with $a&quot;) } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])  "},{"title":"Fx","type":0,"sectionRef":"#","url":"/docs/monix3/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"/docs/monix3/fx#fx","content":"If you use Monix and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.core._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global import effectie.instances.monix3.fx._ val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = &lt;function0&gt;) get1.runSyncUnsafe() // res1: Int = 1  If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"/docs/monix3/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.syntax.all._ import effectie.core._ trait Something[F[_]] { def get[A](a: =&gt; A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: =&gt; A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global import effectie.instances.monix3.fx._ val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = &lt;function0&gt;) get1.runSyncUnsafe() // res3: Int = 1  "}]