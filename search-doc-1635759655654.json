[{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" Effectie​","type":1,"pageTitle":"Getting Started","url":"docs/#effectie-logo-effectie","content":" Project\tMaven Centraleffectie-cats-effect3 effectie-cats-effect effectie-monix effectie-scalaz-effect\t Supported Scala Versions: 3, 2.13 and 2.12 A set of type-classes and utils for functional effect libraries (i.e. Cats Effect, Monix and Scalaz's Effect). Why Effectie? Please read \"Why?\" section. "},{"title":"Getting Started​","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"For Cats Effect​","type":1,"pageTitle":"Getting Started","url":"docs/#for-cats-effect","content":"In build.sbt, Cats Effect 3Cats Effect 2 libraryDependencies += \"io.kevinlee\" %% \"effectie-cats-effect\" % \"1.16.0\" Copy then import import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ Copy For more details, check out Effectie for Cats Effect. "},{"title":"For Monix​","type":1,"pageTitle":"Getting Started","url":"docs/#for-monix","content":"In build.sbt, libraryDependencies += \"io.kevinlee\" %% \"effectie-monix\" % \"1.16.0\" Copy then import import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._ Copy For more details, check out Effectie for Monix. "},{"title":"For Scalaz Effect​","type":1,"pageTitle":"Getting Started","url":"docs/#for-scalaz-effect","content":"In build.sbt, libraryDependencies += \"io.kevinlee\" %% \"effectie-scalaz-effect\" % \"1.16.0\" Copy then import import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ Copy For more details, check out Effectie for Scalaz Effect. "},{"title":"Why?​","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"Tagless final gives us power to defer the decision of the implementations of contexts we're binding and functional effect libraries like Cats Effect and Scalaz Effect give us referential transparency. There might be an issue though with constructing an effect type data. It is actually an issue with Cats Effect as Cats Effect IO's pure (or Monad.pure) is not referentially transparent. Let's check out some code examples. e.g.) Cats Effect import cats.effect._ // or cats.Monad[IO].pure(println(\"a\")) val io = IO.pure(println(\"a\")) // a // io: IO[Unit] = Pure(a = ()) // It is not referentially transparent so immediately evaluates println(\"a\") io.unsafeRunSync() io.unsafeRunSync() Copy e.g.) Scalaz Effect import scalaz._, scalaz.effect._ val io = Monad[IO].pure(println(\"a\")) // io: IO[Unit] = scalaz.effect.IO$$anon$7@1ee46a3d // It is referentially transparent so println(\"a\") is not evaluated here. io.unsafePerformIO() // a io.unsafePerformIO() // a Copy So to have referential transparency when using Cats Effect, IO.apply() should be used. import cats.effect._ val io = IO(println(\"a\")) // io: IO[Unit] = Delay(thunk = <function0>) // Now it is referentially transparent so println(\"a\") is not evaluated here. io.unsafeRunSync() // a io.unsafeRunSync() // a Copy Now, let's use Cats Effect with tagless final. import cats.effect._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]] extends Foo[F] { def get[A](a: => A): F[A] = // How would you construct F[A]? } // call-site val bar = new Bar[IO] bar.get(1) bar.get(println(\"a\")) Copy How would you construct F[A]? You could probably do Applicative[F].pure or Monad[F].pure(a). import cats._ class Bar[F[_]: Applicative] extends Foo[F] { // or [F[_]: Monad] def get[A](a: => A): F[A] = Applicative[F].pure(a) // or Monad[F].pure(a) } Copy However, neither Applicative.pure nor Monad.pure in Cats are referentially transparent when it's mixed with impure code (e.g. some side-effect code like println(\"a\")). So If you do this, val bar = new Bar[IO] val iou = bar.get(println(\"a\")) // a is printed here // and you get IO[Unit] iou.unsafeRunSync() // This does not print anything but returns () Copy With Effectie you can do this. import cats.effect._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: Fx] extends Foo[F] { def get[A](a: => A): F[A] = Fx[F].effectOf(a) } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App9$Bar@276a1aa6 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Copy Or a more convenient way like import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ trait Foo[F[_]] { def get[A](a: => A): F[A] } class Bar[F[_]: Fx] extends Foo[F] { def get[A](a: => A): F[A] = effectOf(a) // no more Fx[F].effectOf } // call-site val bar = new Bar[IO] // bar: Bar[IO] = repl.MdocSession$App12$Bar@6d932410 val iou = bar.get(println(\"a\")) // iou: IO[Unit] = Delay(thunk = <function0>) // This does not print anything here. iou.unsafeRunSync() // a iou.unsafeRunSync() // a Copy Check out Effectie for Cats EffectEffectie for MonixEffectie for Scalaz (v7.2.x) Effect "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"docs/cats-effect/can-handle-error","content":"","keywords":""},{"title":"CanHandleError​","type":1,"pageTitle":"CanHandleError","url":"docs/cats-effect/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA >: A]( fa: => F[A] )( handleError: Throwable => F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA >: A]( fa: => F[A] )( handleError: Throwable => AA ): F[AA] def handleEitherTNonFatal[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => Either[AA, BB] ): EitherT[F, AA, BB] } Copy There are instances available for cats.effect.IO, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal​","type":1,"pageTitle":"CanHandleError","url":"docs/cats-effect/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } println(bar[IO](1).unsafeRunSync()) // 1 println(bar[IO](-1).unsafeRunSync()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0 Copy import effectie.cats._ import effectie.cats.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0 Copy "},{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"Effectie for Cats Effect​","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#effectie-for-cats-effect","content":"FxConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#all-in-one-example","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats.ConsoleEffectful._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ import effectie.cats.OptionTSupport._ import effectie.cats._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa <- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah <- \"blah blah\".someTF[F] // OptionT(Applicative[F].pure(Some(\"blah blah\"))) _ <- effectOf( println(s\"a: $a / BLAH: $blah\") ).someT // OptionT(effectOf(Some(println(s\"a: $a / BLAH: $blah\")))) x <- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ <- effectOf(putStrLn(s\"x: $x\")).someT // OptionT(effectOf(Some(putStrLn(s\"x: $x\")))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah <- \"blah blah\" .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(\"blah blah\".asRight[A])) _ <- effectOf( println(s\"b: $b / BLAH: $blah\") ).rightT[A] // EitherT(effectOf(Right(println(s\"b: $b / BLAH: $blah\")))) x <- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ <- effectOf( putStrLn(s\"x: $x\") ).rightT[A] // EitherT(effectOf(putStrLn(s\"x: $x\").asRight[A])) } yield x).value } } println(Something[IO].foo(1).unsafeRunSync()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafeRunSync()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[IO].bar(none[String]).unsafeRunSync()) // None println(Something[IO].baz(2.asRight[String]).unsafeRunSync()) // b: 2 / BLAH: blah blah // Right(4) println(Something[IO].baz(\"ERROR!!!\".asLeft[Int]).unsafeRunSync()) // Left(ERROR!!!) Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/cats-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"docs/cats-effect/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"docs/cats-effect/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.cats.ConsoleEffectful._ import effectie.cats._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import cats.effect._ val foo = Something[IO].foo() foo.unsafeRunSync() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/cats-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"docs/cats-effect/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- a.rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(a)) y <- (x + 10).rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(x + 10)) y2 <- if (y > 100) \"Error - Bigger than 100\".leftTF[F, Int] else y.rightTF[F, String] // ↑ if (y > 100) // EitherT(pureOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- effectOf(y2 + 100).rightT[String] // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- a.eitherT[F] // == EitherT(pureOf(a: Either[String, Int])) y <- effectOf((x + 999).asRight[String]).eitherT // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Either[String, Int] = Right(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Either[String, Int] = Right(value = 120) Something[IO].bar(1.asRight[String]).unsafeRunSync() // res3: Either[String, Int] = Right(value = 1000) Something[IO].bar(\"No number\".asLeft[Int]).unsafeRunSync() // res4: Either[String, Int] = Left(value = \"No number\") Copy "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"docs/cats-effect/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"docs/cats-effect/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for cats.effect.IOFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: => Future[A]): F[A] } Copy "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"docs/cats-effect/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a <- FromFuture[F].toEffect(foo(n)) b <- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@3043821[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 1, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@13e1b3d8 implicit val cs: ContextShift[IO] = IO.contextShift(ec) // cs: ContextShift[IO] = cats.effect.internals.IOContextShift@6d963540 try { println(MyApp.baz[IO](1).unsafeRunSync()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202 Copy "},{"title":"Fx","type":0,"sectionRef":"#","url":"docs/cats-effect/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"docs/cats-effect/fx#fx","content":"If you use Cats Effect and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = Fx[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"docs/cats-effect/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.cats.Effectful._ import effectie.cats._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import cats.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = Delay(thunk = <function0>) get1.unsafeRunSync() // res3: Int = 1 Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/cats-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"docs/cats-effect/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.cats.Effectful._ import effectie.cats._ import effectie.cats.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y <- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z <- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y <- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).value } } import cats.effect._ Something[IO].foo(1).unsafeRunSync() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafeRunSync() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafeRunSync() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafeRunSync() // res4: Option[Int] = None Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/cats-effect/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@67be7fe4, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) fa.unsafeRunSync() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:117), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App6$.doSomething(can-catch.md:120), // repl.MdocSession$App6$.<clinit>(can-catch.md:123), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:317), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App12$.doSomething(can-catch.md:320), // repl.MdocSession$App12$.<clinit>(can-catch.md:323), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(Markd... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-1","content":"IOFutureId import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@502914ab, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@25fdf0ac, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... fa.unsafeRunSync() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:597), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App24$.doSomething(can-catch.md:600), // repl.MdocSession$App24$.<clinit>(can-catch.md:603), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:829), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App30$.doSomething(can-catch.md:832), // repl.MdocSession$App30$.<clinit>(can-catch.md:835), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // repl.MdocSession$App18$.<clinit>(can-catch.md:494), // repl.MdocSession$App16$.<clinit>(can-catch.md:474), // repl.MdocSession$App14$.<clinit>(can-catch.md:417), // repl.MdocSession$App12$.<clinit>(can-catch.md:337), // repl.MdocSession$App10$.<clinit>(can-catch.md:274), // repl.MdocSession$App8$.<clinit>(can-catch.md:217), // repl.MdocSession$App6$.<clinit>(can-catch.md:137), // repl.MdocSession$App4$.<clinit>(can-catch.md:74), // repl.MdocSession$App2$.<clinit>(can-catch.md:57), // repl.MdocSession$App0$.<clinit>(can-catch.md:25), // repl.MdocSession$App.<init>(can-catch.md:5), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-2","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@1540c675, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@dfb0ecf, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // ... fa.value.unsafeRunSync() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-2","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@5c558c58, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.EitherTSupport._ import effectie.cats.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@f49213f, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-3","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[Either[Throwable, Nothing]] = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@62601267, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) fa.unsafeRunSync() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1703), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1706), // repl.MdocSession$App60$.<clinit>(can-catch.md:1709), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // repl.MdocSession$App42$.<clinit>(can-catch.md:1168), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // repl.MdocSession$App20$.<clinit>(can-catch.md:526), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[Either[MyError, Int]] = Map( // source = Bind( // source = Bind( // source = Pure(a = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1913), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1916), // repl.MdocSession$App66$.<clinit>(can-catch.md:1919), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // repl.MdocSession$App48$.<clinit>(can-catch.md:1418), // repl.MdocSession$App46$.<clinit>(can-catch.md:1338), // repl.MdocSession$App44$.<clinit>(can-catch.md:1264), // repl.MdocSession$App42$.<clinit>(can-catch.md:1168), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-4","content":"IOFutureId import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: IO[Either[Throwable, Int]] = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@45d688f1, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@5b9940bc, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... fa.unsafeRunSync() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2202), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2205), // repl.MdocSession$App78$.<clinit>(can-catch.md:2208), // repl.MdocSession$App76$.<clinit>(can-catch.md:2145), // repl.MdocSession$App74$.<clinit>(can-catch.md:2128), // repl.MdocSession$App72$.<clinit>(can-catch.md:2096), // repl.MdocSession$App70$.<clinit>(can-catch.md:2076), // repl.MdocSession$App68$.<clinit>(can-catch.md:2016), // repl.MdocSession$App66$.<clinit>(can-catch.md:1933), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // repl.MdocSession$App54$.<clinit>(can-catch.md:1608), // repl.MdocSession$App52$.<clinit>(can-catch.md:1588), // repl.MdocSession$App50$.<clinit>(can-catch.md:1514), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2443), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.cats.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2446), // repl.MdocSession$App84$.<clinit>(can-catch.md:2449), // repl.MdocSession$App82$.<clinit>(can-catch.md:2386), // repl.MdocSession$App80$.<clinit>(can-catch.md:2315), // repl.MdocSession$App78$.<clinit>(can-catch.md:2222), // repl.MdocSession$App76$.<clinit>(can-catch.md:2145), // repl.MdocSession$App74$.<clinit>(can-catch.md:2128), // repl.MdocSession$App72$.<clinit>(can-catch.md:2096), // repl.MdocSession$App70$.<clinit>(can-catch.md:2076), // repl.MdocSession$App68$.<clinit>(can-catch.md:2016), // repl.MdocSession$App66$.<clinit>(can-catch.md:1933), // repl.MdocSession$App64$.<clinit>(can-catch.md:1867), // repl.MdocSession$App62$.<clinit>(can-catch.md:1807), // repl.MdocSession$App60$.<clinit>(can-catch.md:1723), // repl.MdocSession$App58$.<clinit>(can-catch.md:1657), // repl.MdocSession$App56$.<clinit>(can-catch.md:1640), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#how-to-use-5","content":"IOFutureId import cats.data.EitherT import cats.effect._ import effectie.cats.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = Bind( // source = Delay(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@452bd643, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.map(IO.scala:106), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@1a7645b2, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // ... fa.value.unsafeRunSync() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#happy-path-example-5","content":"IOFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@21d9e611, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/cats-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import cats.effect._ import effectie.cats._ import effectie.cats.Effectful._ import effectie.cats.Catching._ import effectie.cats.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[IO](-1) // fa: IO[Either[MyError, Int]] = Map( // source = Map( // source = Bind( // source = Bind( // source = Pure(a = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@441c62d2, // trace = StackTrace( // stackTrace = List( // cats.effect.internals.IOTracing$.buildFrame(IOTracing.scala:48), // cats.effect.internals.IOTracing$.buildCachedFrame(IOTracing.scala:39), // cats.effect.internals.IOTracing$.cached(IOTracing.scala:34), // cats.effect.IO.flatMap(IO.scala:133), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:886), // cats.effect.IOLowPriorityInstances$IOEffect.flatMap(IO.scala:863), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1148), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.cats.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1151), // repl.MdocSession$App42$.<clinit>(can-catch.md:1154), // repl.MdocSession$App40$.<clinit>(can-catch.md:1088), // repl.MdocSession$App38$.<clinit>(can-catch.md:1065), // repl.MdocSession$App36$.<clinit>(can-catch.md:1030), // repl.MdocSession$App34$.<clinit>(can-catch.md:1007), // repl.MdocSession$App32$.<clinit>(can-catch.md:939), // repl.MdocSession$App30$.<clinit>(can-catch.md:849), // repl.MdocSession$App28$.<clinit>(can-catch.md:775), // repl.MdocSession$App26$.<clinit>(can-catch.md:707), // repl.MdocSession$App24$.<clinit>(can-catch.md:617), // repl.MdocSession$App22$.<clinit>(can-catch.md:543), // ... val result = fa.unsafeRunSync() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanHandleError","type":0,"sectionRef":"#","url":"docs/monix/can-handle-error","content":"","keywords":""},{"title":"CanHandleError​","type":1,"pageTitle":"CanHandleError","url":"docs/monix/can-handle-error#canhandleerror","content":"CanHandleError is a typeclass to handle NonFatal Throwable and to recover from it. It looks like this. trait CanHandleError[F[_]] { def handleNonFatalWith[A, AA >: A]( fa: => F[A] )( handleError: Throwable => F[AA] ): F[AA] def handleEitherTNonFatalWith[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => F[Either[AA, BB]] ): EitherT[F, AA, BB] def handleNonFatal[A, AA >: A]( fa: => F[A] )( handleError: Throwable => AA ): F[AA] def handleEitherTNonFatal[A, AA >: A, B, BB >: B]( efab: => EitherT[F, A, B] )( handleError: Throwable => Either[AA, BB] ): EitherT[F, AA, BB] } Copy There are instances available for monix.eval.Task, scala.concurrent.Future and cats.Id. "},{"title":"CanHandleError.handleNonFatal​","type":1,"pageTitle":"CanHandleError","url":"docs/monix/can-handle-error#canhandleerrorhandlenonfatal","content":"import cats._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } import monix.execution.Scheduler.Implicits.global println(bar[Task](1).runSyncUnsafe()) // 1 println(bar[Task](-1).runSyncUnsafe()) // 0 println(bar[Id](1)) // 1 println(bar[Id](-1)) // 0 Copy import effectie.monix._ import effectie.monix.Effectful._ import scala.util.control.NonFatal import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future, Await} import scala.concurrent.duration._ object MyApp { class InvalidNumberException(n: Int, message: String) extends RuntimeException(message) def foo(n: Int): Int = if (n < 0) throw new InvalidNumberException(n, s\"n cannot be a negative Int. n: $n\") else n def bar[F[_]: Fx: CanHandleError](n: Int): F[Int] = CanHandleError[F].handleNonFatalWith(effectOf(foo(n))) { case NonFatal(err) => pureOf(0) } def main(args: Array[String]): Unit = { val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) try { println(Await.result(bar[Future](1), 1.second)) println(Await.result(bar[Future](-1), 1.second)) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } } } MyApp.main(Array.empty) // 1 // 0 Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/monix/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"docs/monix/console-effect#consoleeffect","content":"import cats._ import cats.syntax.all._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"docs/monix/console-effect#consoleeffectful","content":"import cats._ import cats.syntax.all._ import effectie.monix.ConsoleEffectful._ import effectie.monix._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val foo = Something[Task].foo() foo.runSyncUnsafe() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/monix/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEither[A, B](fab: => F[Either[A, B]])(f: Throwable => A): F[Either[A, B]] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatal( Task(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@2aa099f3, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res1: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App6$$anonfun$doSomething$1.apply(can-catch.md:120), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App6$.doSomething(can-catch.md:123), // repl.MdocSession$App6$.<clinit>(can-catch.md:126), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(Markd... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App12$$anonfun$doSomething$7.apply(can-catch.md:323), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App12$.doSomething(can-catch.md:326), // repl.MdocSession$App12$.<clinit>(can-catch.md:329), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[Either[A, B]]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-1","content":"TaskFutureId import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEither( Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@2cacfe39, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@63f2e634, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res19: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App24$$anonfun$doSomething$13.apply(can-catch.md:609), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App24$.doSomething(can-catch.md:612), // repl.MdocSession$App24$.<clinit>(can-catch.md:615), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // repl.MdocSession$App12$.<clinit>(can-catch.md:346), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // repl.MdocSession$App2$.<clinit>(can-catch.md:60), // repl.MdocSession$App0$.<clinit>(can-catch.md:28), // repl.MdocSession$App.<init>(can-catch.md:5), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-1","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App30$$anonfun$doSomething$19.apply(can-catch.md:844), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // repl.MdocSession$App30$.doSomething(can-catch.md:847), // repl.MdocSession$App30$.<clinit>(can-catch.md:850), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // repl.MdocSession$App24$.<clinit>(can-catch.md:632), // repl.MdocSession$App22$.<clinit>(can-catch.md:555), // repl.MdocSession$App20$.<clinit>(can-catch.md:538), // repl.MdocSession$App18$.<clinit>(can-catch.md:506), // repl.MdocSession$App16$.<clinit>(can-catch.md:483), // repl.MdocSession$App14$.<clinit>(can-catch.md:426), // repl.MdocSession$App12$.<clinit>(can-catch.md:346), // repl.MdocSession$App10$.<clinit>(can-catch.md:280), // repl.MdocSession$App8$.<clinit>(can-catch.md:223), // repl.MdocSession$App6$.<clinit>(can-catch.md:143), // repl.MdocSession$App4$.<clinit>(can-catch.md:77), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-2","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix._ val fa = CanCatch[Task].catchNonFatalEitherT( EitherT(Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@3d73d7d6, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@3d27f17a, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res37: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-2","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@7fff6f96, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-2","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.EitherTSupport._ import effectie.monix.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@3b518a1a, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-3","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatal( Task(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: Task[Either[Throwable, Nothing]] = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@370789b0, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ) import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res55: Either[Throwable, Nothing] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = 101), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App60$$anonfun$doSomething$37.apply(can-catch.md:1733), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App60$.doSomething(can-catch.md:1736), // repl.MdocSession$App60$.<clinit>(can-catch.md:1739), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // repl.MdocSession$App46$.<clinit>(can-catch.md:1362), // repl.MdocSession$App44$.<clinit>(can-catch.md:1288), // repl.MdocSession$App42$.<clinit>(can-catch.md:1192), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // repl.MdocSession$App26$.<clinit>(can-catch.md:722), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 202) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-3","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[Task](-101) // fa: Task[Either[MyError, Int]] = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = -1), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App66$$anonfun$doSomething$43.apply(can-catch.md:1946), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatch2$.apply$extension(Catching.scala:45), // repl.MdocSession$App66$.doSomething(can-catch.md:1949), // repl.MdocSession$App66$.<clinit>(can-catch.md:1952), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // repl.MdocSession$App60$.<clinit>(can-catch.md:1756), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // repl.MdocSession$App54$.<clinit>(can-catch.md:1638), // repl.MdocSession$App52$.<clinit>(can-catch.md:1615), // repl.MdocSession$App50$.<clinit>(can-catch.md:1541), // repl.MdocSession$App48$.<clinit>(can-catch.md:1445), // repl.MdocSession$App46$.<clinit>(can-catch.md:1362), // repl.MdocSession$App44$.<clinit>(can-catch.md:1288), // repl.MdocSession$App42$.<clinit>(can-catch.md:1192), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[Either[A, B]] and returns F[Either[A, B]]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-4","content":"TaskFutureId import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEither( Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]) )(identity) // fa: Task[Either[Throwable, Int]] = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@1dee873b, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@680f08c3, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // ... import monix.execution.Scheduler.Implicits.global fa.runSyncUnsafe() // res73: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App78$$anonfun$doSomething$49.apply(can-catch.md:2241), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App78$.doSomething(can-catch.md:2244), // repl.MdocSession$App78$.<clinit>(can-catch.md:2247), // repl.MdocSession$App76$.<clinit>(can-catch.md:2184), // repl.MdocSession$App74$.<clinit>(can-catch.md:2167), // repl.MdocSession$App72$.<clinit>(can-catch.md:2135), // repl.MdocSession$App70$.<clinit>(can-catch.md:2112), // repl.MdocSession$App68$.<clinit>(can-catch.md:2052), // repl.MdocSession$App66$.<clinit>(can-catch.md:1969), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // repl.MdocSession$App60$.<clinit>(can-catch.md:1756), // repl.MdocSession$App58$.<clinit>(can-catch.md:1687), // repl.MdocSession$App56$.<clinit>(can-catch.md:1670), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-4","content":"TaskFutureId import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = <function1>, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.FlatMap$Ops.flatMap(FlatMap.scala:229), // cats.FlatMap$Ops.flatMap$(FlatMap.scala:229), // cats.FlatMap$ToFlatMapOps$$anon$2.flatMap(FlatMap.scala:243), // repl.MdocSession$App84$$anonfun$doSomething$55.apply(can-catch.md:2485), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.monix.Catching$CurriedCanCatchEither2$.apply$extension(Catching.scala:74), // repl.MdocSession$App84$.doSomething(can-catch.md:2488), // repl.MdocSession$App84$.<clinit>(can-catch.md:2491), // repl.MdocSession$App82$.<clinit>(can-catch.md:2428), // repl.MdocSession$App80$.<clinit>(can-catch.md:2357), // repl.MdocSession$App78$.<clinit>(can-catch.md:2264), // repl.MdocSession$App76$.<clinit>(can-catch.md:2184), // repl.MdocSession$App74$.<clinit>(can-catch.md:2167), // repl.MdocSession$App72$.<clinit>(can-catch.md:2135), // repl.MdocSession$App70$.<clinit>(can-catch.md:2112), // repl.MdocSession$App68$.<clinit>(can-catch.md:2052), // repl.MdocSession$App66$.<clinit>(can-catch.md:1969), // repl.MdocSession$App64$.<clinit>(can-catch.md:1900), // repl.MdocSession$App62$.<clinit>(can-catch.md:1840), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#how-to-use-5","content":"TaskFutureId import cats.data.EitherT import monix.eval._ import effectie.monix.Catching._ val fa = catchNonFatalEitherT[Task]( EitherT(Task((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])) )(identity) // fa: EitherT[Task, Throwable, Int] = EitherT( // value = Map( // source = Map( // source = FlatMap( // source = Eval(thunk = <function0>), // f = <function1>, // trace = null // ), // f = effectie.CanCatch$$Lambda$10953/0x00000001034bc040@2df00aa4, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.map(Task.scala:2027), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.mapFa(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // repl.MdocSession$App0$.<clinit>(can-catch.md:19), // repl.MdocSession$App.<init>(can-catch.md:5), // repl.MdocSession$.app(can-catch.md:3), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withErr(Console.scala:193), // mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:89), // scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18), // scala.util.DynamicVariable.withValue(DynamicVariable.scala:59), // scala.Console$.withOut(Console.scala:164), // mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:88), // mdoc.internal.markdown.MarkdownBuilder$.$anonfun$buildDocument$2(MarkdownBuilder.scala:47), // mdoc.internal.markdown.MarkdownBuilder$$anon$1.run(MarkdownBuilder.scala:103) // ) // ) // ), // f = effectie.CanCatch$$Lambda$10972/0x00000001034dd840@57a12d4, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // ... import monix.execution.Scheduler.Implicits.global fa.value.runSyncUnsafe() // res91: Either[Throwable, Int] = Left( // value = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#happy-path-example-5","content":"TaskFutureId import cats._ import cats.syntax.all._ import cats.data.EitherT import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = 100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@22cc0b21, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Right(value = 200) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/monix/can-catch#unhappy-path-example-5","content":"TaskFutureId import cats._ import cats.data.EitherT import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.monix.Catching._ import effectie.monix.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): Either[MyError, Int] = if (n === 0) MyError.divideByZero.asLeft[Int] else (100 / n).asRight[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[Either[MyError, Int]] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).value val fa = doSomething[Task](-1) // fa: Task[Either[MyError, Int]] = Map( // source = Map( // source = FlatMap( // source = FlatMap( // source = Now(value = Right(value = -100)), // f = cats.data.EitherT$$Lambda$10974/0x00000001034dc840@3da5b63a, // trace = StackTrace( // stackTrace = List( // monix.eval.internal.TaskTracing$.buildFrame(TaskTracing.scala:52), // monix.eval.internal.TaskTracing$.buildCachedFrame(TaskTracing.scala:43), // monix.eval.internal.TaskTracing$.cached(TaskTracing.scala:38), // monix.eval.Task.flatMap(Task.scala:1792), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:39), // monix.eval.instances.CatsBaseForTask.flatMap(CatsBaseForTask.scala:33), // cats.data.EitherT.flatMap(EitherT.scala:403), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // repl.MdocSession$App42$$anonfun$doSomething$25.apply(can-catch.md:1169), // effectie.CanCatch.$anonfun$catchNonFatalEitherT$1(CanCatch.scala:28), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:31), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalThrowable(CanCatch.scala:26), // effectie.CanCatch.catchNonFatal(CanCatch.scala:22), // effectie.CanCatch.catchNonFatal$(CanCatch.scala:21), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatal(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEither(CanCatch.scala:25), // effectie.CanCatch.catchNonFatalEither$(CanCatch.scala:24), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEither(CanCatch.scala:26), // effectie.CanCatch.catchNonFatalEitherT(CanCatch.scala:28), // effectie.CanCatch.catchNonFatalEitherT$(CanCatch.scala:27), // effectie.monix.CanCatch$CanCatchIo$.catchNonFatalEitherT(CanCatch.scala:26), // repl.MdocSession$App42$.doSomething(can-catch.md:1172), // repl.MdocSession$App42$.<clinit>(can-catch.md:1175), // repl.MdocSession$App40$.<clinit>(can-catch.md:1109), // repl.MdocSession$App38$.<clinit>(can-catch.md:1086), // repl.MdocSession$App36$.<clinit>(can-catch.md:1051), // repl.MdocSession$App34$.<clinit>(can-catch.md:1025), // repl.MdocSession$App32$.<clinit>(can-catch.md:957), // repl.MdocSession$App30$.<clinit>(can-catch.md:867), // repl.MdocSession$App28$.<clinit>(can-catch.md:790), // ... import monix.execution.Scheduler.Implicits.global val result = fa.runSyncUnsafe() // result: Either[MyError, Int] = Left( // value = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case Right(b) => println(s\"Result is $b\") case Left(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"FromFuture","type":0,"sectionRef":"#","url":"docs/monix/from-future","content":"","keywords":""},{"title":"FromFuture​","type":1,"pageTitle":"FromFuture","url":"docs/monix/from-future#fromfuture","content":"FromFuture is a typeclass to convert scala.concurrent.Future to an effect, F[_]. So if there are some APIs returning Future, it can be converted to F[_]. There are three FromFuture instances available. FromFuture for monix.eval.TaskFromFuture for scala.concurrent.FutureFromFuture for cats.Id trait FromFuture[F[_]] { def toEffect[A](future: => Future[A]): F[A] } Copy "},{"title":"FromFuture.toEffect​","type":1,"pageTitle":"FromFuture","url":"docs/monix/from-future#fromfuturetoeffect","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix._ import effectie.monix.Effectful._ import effectie.concurrent.ExecutorServiceOps import java.util.concurrent.{ExecutorService, Executors} import scala.concurrent.{ExecutionContext, Future} import scala.concurrent.duration._ object MyApp { def foo(n: Int)(implicit ec: ExecutionContext): Future[Int] = Future(n + 100) def bar[F[_]: Fx](n: Int): F[Int] = pureOf(n * 2) def baz[F[_]: Monad: Fx: FromFuture](n: Int)(implicit ec: ExecutionContext): F[Int] = for { a <- FromFuture[F].toEffect(foo(n)) b <- bar[F](a) } yield b } val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors() >> 1) // executorService: ExecutorService = java.util.concurrent.ForkJoinPool@5c90226b[Terminated, parallelism = 1, size = 0, active = 0, running = 0, steals = 0, tasks = 0, submissions = 0] implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService) // ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@2ab99688 import monix.execution.Scheduler.Implicits.global try { println(MyApp.baz[Task](1).runSyncUnsafe()) } finally { ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second) } // 202 Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/monix/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"docs/monix/eithert-support#eithertsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[Either[String, Int]] def bar(a: Either[String, Int]): F[Either[String, Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Either[String, Int]] = (for { x <- a.rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(a)) y <- (x + 10).rightTF[F, String] // == EitherT.liftF(Applicative[F].pure(x + 10)) y2 <- if (y > 100) \"Error - Bigger than 100\".leftTF[F, Int] else y.rightTF[F, String] // ↑ if (y > 100) // EitherT(pureOf(\"Error - Bigger than 100\").map(_.asLeft[Int])) // else // EitherT(pureOf(y).map(_.asRight[String])) z <- effectOf(y2 + 100).rightT[String] // == EitherT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Either[String, Int]): F[Either[String, Int]] = (for { x <- a.eitherT[F] // == EitherT(pureOf(a: Either[String, Int])) y <- effectOf((x + 999).asRight[String]).eitherT // == EitherT(effectOf((x + 999).asRight[String])) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Either[String, Int] = Right(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Either[String, Int] = Right(value = 120) Something[Task].bar(1.asRight[String]).runSyncUnsafe() // res3: Either[String, Int] = Right(value = 1000) Something[Task].bar(\"No number\".asLeft[Int]).runSyncUnsafe() // res4: Either[String, Int] = Left(value = \"No number\") Copy "},{"title":"Fx","type":0,"sectionRef":"#","url":"docs/monix/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"docs/monix/fx#fx","content":"If you use Monix and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.monix._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = <function0>) get1.runSyncUnsafe() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"docs/monix/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.monix.Effectful._ import effectie.monix._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import monix.eval._ import monix.execution.Scheduler.Implicits.global val get1 = Something[Task].get(1) // get1: Task[Int] = Eval(thunk = <function0>) get1.runSyncUnsafe() // res3: Int = 1 Copy "},{"title":"For Monix","type":0,"sectionRef":"#","url":"docs/monix/monix","content":"","keywords":""},{"title":"Effectie for Monix​","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#effectie-for-monix","content":"FxConsoleEffectCanCatchCanHandleErrorFromFutureOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Monix","url":"docs/monix/monix#all-in-one-example","content":"import cats._ import cats.syntax.all._ import monix.eval._ import effectie.monix.ConsoleEffectful._ import effectie.monix.Effectful._ import effectie.monix.EitherTSupport._ import effectie.monix.OptionTSupport._ import effectie.monix._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A, B: Semigroup](a: Either[A, B]): F[Either[A, B]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa <- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah <- \"blah blah\".someTF[F] // OptionT(Applicative[F].pure(Some(\"blah blah\"))) _ <- effectOf( println(s\"a: $a / BLAH: $blah\") ).someT // OptionT(effectOf(Some(println(s\"a: $a / BLAH: $blah\")))) x <- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ <- effectOf(putStrLn(s\"x: $x\")).someT // OptionT(effectOf(Some(putStrLn(s\"x: $x\")))) } yield x).value override def baz[A, B: Semigroup](ab: Either[A, B]): F[Either[A, B]] = (for { b <- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah <- \"blah blah\" .asRight[A] .eitherT[F] // EitherT(Applicative[F].pure(\"blah blah\".asRight[A])) _ <- effectOf( println(s\"b: $b / BLAH: $blah\") ).rightT[A] // EitherT(effectOf(Right(println(s\"b: $b / BLAH: $blah\")))) x <- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ <- effectOf( putStrLn(s\"x: $x\") ).rightT[A] // EitherT(effectOf(putStrLn(s\"x: $x\").asRight[A])) } yield x).value } } import monix.execution.Scheduler.Implicits.global println(Something[Task].foo(1).runSyncUnsafe()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[Task].bar(2.some).runSyncUnsafe()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[Task].bar(none[String]).runSyncUnsafe()) // None println(Something[Task].baz(2.asRight[String]).runSyncUnsafe()) // b: 2 / BLAH: blah blah // Right(4) println(Something[Task].baz(\"ERROR!!!\".asLeft[Int]).runSyncUnsafe()) // Left(ERROR!!!) Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/monix/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"docs/monix/optiont-support#optiontsupport","content":"import cats._ import cats.syntax.all._ import effectie.monix.Effectful._ import effectie.monix._ import effectie.monix.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y <- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z <- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).value def bar(a: Option[Int]): F[Option[Int]] = (for { x <- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y <- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).value } } import monix.eval._ import monix.execution.Scheduler.Implicits.global Something[Task].foo(1).runSyncUnsafe() // res1: Option[Int] = Some(value = 111) Something[Task].foo(10).runSyncUnsafe() // res2: Option[Int] = Some(value = 120) Something[Task].bar(1.some).runSyncUnsafe() // res3: Option[Int] = Some(value = 1000) Something[Task].bar(none[Int]).runSyncUnsafe() // res4: Option[Int] = None Copy "},{"title":"ConsoleEffect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/console-effect","content":"","keywords":""},{"title":"ConsoleEffect​","type":1,"pageTitle":"ConsoleEffect","url":"docs/scalaz-effect/console-effect#consoleeffect","content":"import scalaz._ import Scalaz._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- ConsoleEffect[F].putStrLn(\"Hello\") answer <- ConsoleEffect[F].readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- ConsoleEffect[F].putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"ConsoleEffectful​","type":1,"pageTitle":"ConsoleEffect","url":"docs/scalaz-effect/console-effect#consoleeffectful","content":"import scalaz._ import Scalaz._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz._ import effectie.YesNo trait Something[F[_]] { def foo[A](): F[Unit] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: ConsoleEffect: Monad] extends Something[F] { def foo[A](): F[Unit] = for { _ <- putStrLn(\"Hello\") answer <- readYesNo(\"Would you like to proceed?\") result = answer match { case YesNo.Yes => \"Done\" case YesNo.No => \"Cancelled\" } _ <- putStrLn(result) } yield () } } import scalaz.effect._ val foo = Something[IO].foo() foo.unsafePerformIO() Copy Hello Would you like to proceed? n Cancelled Copy Hello Would you like to proceed? y Done Copy "},{"title":"EitherTSupport","type":0,"sectionRef":"#","url":"docs/scalaz-effect/eithert-support","content":"","keywords":""},{"title":"EitherTSupport​","type":1,"pageTitle":"EitherTSupport","url":"docs/scalaz-effect/eithert-support#eithertsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ trait Something[F[_]] { def foo(a: Int): F[String \\/ Int] def bar(a: String \\/ Int): F[String \\/ Int] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[String \\/ Int] = (for { x <- a.rightTF[F, String] // == EitherT(Applicative[F].pure(a).map(_.right[String])) y <- (x + 10).rightTF[F, String] // == EitherT(Applicative[F].pure(x + 10).map(_.right[String])) y2 <- if (y > 100) eitherTLeft[Int](\"Error - Bigger than 100\") else eitherTRightPure[String](y) // ↑ if (y > 100) // EitherT(pureOF(\"Error - Bigger than 100\").map(_.left[Int])) // else // EitherT(pureOf(y).map(_.right[String])) z <- effectOf(y2 + 100).rightT[String] // == EitherT(effectOf(y + 100).map(_.right)) } yield z).run def bar(a: String \\/ Int): F[String \\/ Int] = (for { x <- a.eitherT[F] // == EitherT(pureOf(a: String \\/ Int)) y <- effectOf((x + 999).right[String]).eitherT // == EitherT(effectOf((x + 999).right[String])) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: String \\/ Int = \\/-(b = 111) Something[IO].foo(10).unsafePerformIO() // res2: String \\/ Int = \\/-(b = 120) Something[IO].bar(1.right[String]).unsafePerformIO() // res3: String \\/ Int = \\/-(b = 1000) Something[IO].bar(\"No number\".left[Int]).unsafePerformIO() // res4: String \\/ Int = -\\/(a = \"No number\") Copy "},{"title":"Fx","type":0,"sectionRef":"#","url":"docs/scalaz-effect/fx","content":"","keywords":""},{"title":"Fx​","type":1,"pageTitle":"Fx","url":"docs/scalaz-effect/fx#fx","content":"If you use Scalaz Effect and write tagless final code, and look for a generic way to construct F[A], Fx can help you. import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = Fx[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@ff1dc5f get1.unsafePerformIO() // res1: Int = 1 Copy If you feel it's too cumbersome to repeat Fx[F].effectOf(), consider using Effectful "},{"title":"Effectful​","type":1,"pageTitle":"Fx","url":"docs/scalaz-effect/fx#effectful","content":"If you're sick of repeating Fx[F].effectOf() and looking for more convenient ways?, use Effectful instead. import effectie.scalaz.Effectful._ import effectie.scalaz._ trait Something[F[_]] { def get[A](a: => A): F[A] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx] extends Something[F] { def get[A](a: => A): F[A] = effectOf(a) // No more Fx[F].effectOf(a) } } import scalaz.effect._ val get1 = Something[IO].get(1) // get1: IO[Int] = scalaz.effect.IO$$anon$7@d7c959e get1.unsafePerformIO() // res3: Int = 1 Copy "},{"title":"OptionTSupport","type":0,"sectionRef":"#","url":"docs/scalaz-effect/optiont-support","content":"","keywords":""},{"title":"OptionTSupport​","type":1,"pageTitle":"OptionTSupport","url":"docs/scalaz-effect/optiont-support#optiontsupport","content":"import scalaz._ import Scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz._ import effectie.scalaz.OptionTSupport._ trait Something[F[_]] { def foo(a: Int): F[Option[Int]] def bar(a: Option[Int]): F[Option[Int]] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: Monad] extends Something[F] { def foo(a: Int): F[Option[Int]] = (for { x <- a.someTF[F] // == OptionT.liftF(Applicative[F].pure(a)) y <- (x + 10).someTF[F] // == OptionT.liftF(Applicative[F].pure(x + 10)) z <- effectOf(y + 100).someT // == OptionT.lieftF(effectOf(y + 100)) } yield z).run def bar(a: Option[Int]): F[Option[Int]] = (for { x <- a.optionT[F] // == OptionT(pureOf(a: Option[Int])) y <- effectOf((x + 999).some).optionT // == OptionT(effectOf((x + 999).some)) } yield y).run } } import scalaz.effect._ Something[IO].foo(1).unsafePerformIO() // res1: Option[Int] = Some(value = 111) Something[IO].foo(10).unsafePerformIO() // res2: Option[Int] = Some(value = 120) Something[IO].bar(1.some).unsafePerformIO() // res3: Option[Int] = Some(value = 1000) Something[IO].bar(none[Int]).unsafePerformIO() // res4: Option[Int] = None Copy "},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"Effectie for Scalaz Effect​","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#effectie-for-scalaz-effect","content":"FxConsoleEffectOptionTSupportEitherTSupport "},{"title":"All in One Example​","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#all-in-one-example","content":"import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.ConsoleEffectful._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.OptionTSupport._ import effectie.scalaz._ trait Something[F[_]] { def foo[A: Semigroup](a: A): F[A] def bar[A: Semigroup](a: Option[A]): F[Option[A]] def baz[A: Semigroup, B: Semigroup](a: A \\/ B): F[A \\/ B] } object Something { def apply[F[_]: Something]: Something[F] = implicitly[Something[F]] implicit def something[F[_]: Fx: ConsoleEffect: Monad]: Something[F] = new SomethingF[F] final class SomethingF[F[_]: Fx: ConsoleEffect: Monad] extends Something[F] { override def foo[A: Semigroup](a: A): F[A] = for { n <- effectOf(a) blah <- pureOf(\"blah blah\") _ <- effectOf(println(s\"n: $n / BLAH: $blah\")) x <- effectOf(n |+| n) _ <- putStrLn(s\"x: $x\") } yield x override def bar[A: Semigroup](a: Option[A]): F[Option[A]] = (for { aa <- a.optionT[F] // OptionT(Applicative[F].pure(a)) blah <- \"blah blah\".someTF[F] // OptionT(Applicative[F].pure(Some(\"blah blah\"))) _ <- effectOf( println(s\"a: $a / BLAH: $blah\") ).someT // OptionT(effectOf(Some(println(s\"a: $a / BLAH: $blah\")))) x <- effectOf(a |+| a).optionT // OptionT(effectOf(a |+| a)) _ <- effectOf(putStrLn(s\"x: $x\")).someT // OptionT(effectOf(Some(putStrLn(s\"x: $x\")))) } yield x).run override def baz[A: Semigroup, B: Semigroup](ab: A \\/ B): F[A \\/ B] = (for { b <- ab.eitherT[F] // EitherT(Applicative[F].pure(ab)) blah <- \"blah blah\" .right[A] .eitherT[F] // EitherT(Applicative[F].pure(\"blah blah\".right[A])) _ <- effectOf( println(s\"b: $b / BLAH: $blah\") ).rightT[A] // EitherT(effectOf(\\/-(println(s\"b: $b / BLAH: $blah\")))) x <- effectOf(ab |+| ab).eitherT // EitherT(effectOf(ab |+| ab)) _ <- effectOf( putStrLn(s\"x: $x\") ).rightT[A] // EitherT(effectOf(putStrLn(s\"x: $x\").right[A])) } yield x).run } } println(Something[IO].foo(1).unsafePerformIO()) // n: 1 / BLAH: blah blah // x: 2 // 2 println(Something[IO].bar(2.some).unsafePerformIO()) // a: Some(2) / BLAH: blah blah // Some(4) println(Something[IO].bar(none[String]).unsafePerformIO()) // None println(Something[IO].baz(2.right[String]).unsafePerformIO()) // b: 2 / BLAH: blah blah // \\/-(4) println(Something[IO].baz(\"ERROR!!!\".left[Int]).unsafePerformIO()) // -\\/(ERROR!!!) Copy "},{"title":"CanCatch","type":0,"sectionRef":"#","url":"docs/scalaz-effect/can-catch","content":"","keywords":""},{"title":"CanCatch​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatch","content":"CanCatch lets you catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. It takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. trait CanCatch[F[_]] { def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEither[A, B](fab: => F[A \\/ B])(f: Throwable => A): F[A \\/ B] def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B] } Copy "},{"title":"CanCatch.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfatal","content":"CanCatch[F].catchNonFatal[A, B] lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use","content":"IOFutureId import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatal( IO(throw new RuntimeException(\"Something's wrong!\")) )(identity) // fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@1956e398 fa.unsafePerformIO() // res1: scalaz.\\/[Throwable, Nothing] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@66ca6aa1 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@3b7e489 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"CanCatch.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleither","content":"CanCatch[F].catchNonFatalEither[A, B] lets you catch NonFatal Throwable from F[A \\/ B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-1","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@16dab386 fa.unsafePerformIO() // res19: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@7e414824 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-1","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2990c0f9 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"CanCatch.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#cancatchcatchnonfataleithert","content":"CanCatch[F].catchNonFatalEitherT[A, B] lets you catch NonFatal Throwable from EitherT[F, A, B]and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-2","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz._ val fa = CanCatch[IO].catchNonFatalEitherT( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@2c387ec3 // ) fa.run.unsafePerformIO() // res37: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@72b40e07 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-2","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.EitherTSupport._ import effectie.scalaz.Effectful._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = CanCatch[F].catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@428de39d val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catching","content":"Catching.catchNonFatal provides a convenient way to use CanCatch to catch NonFatal Throwable in the F[A]and turned it into F[Either[Throwable, A]]. Just like CanCatch, it takes a function from Throwableto your own error type, yet it can handle only NonFatal ones as already mentioned. "},{"title":"Catching.catchNonFatal​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfatal","content":"catchNonFatal lets you catch NonFatal Throwable from F[B]and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-3","content":"IOFutureId import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatal( IO((throw new RuntimeException(\"Something's wrong!\")): Int) )(identity) // fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@2de15afa fa.unsafePerformIO() // res55: scalaz.\\/[Throwable, Int] = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@70a58189 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 202) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result is 202 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-3","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) } def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatal( for { a <- pureOf(n + 100) b <- effectOf(doSomethingBad(a)) } yield b )(MyError.nonFatalThrowable) val fa = doSomething[IO](-101) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@5502bb14 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(MyError.NonFatalThrowable(a)) => println(s\"Result: Failed with $a\") } // Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1] Copy "},{"title":"Catching.catchNonFatalEither​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleither","content":"Catching.catchNonFatalEither provides a convenient way to use CanCatchto catch NonFatal Throwable from F[A \\/ B] and returns F[A \\/ B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-4","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEither( IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int) )(identity) // fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@3e00b8a9 fa.unsafePerformIO() // res73: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@5ae3a764 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-4","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEither( for { aOrB <- pureOf(divide100By(n)) c <- effectOf(aOrB.map(b => doSomethingBad(b))) } yield c )(MyError.nonFatalThrowable) val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@19c4763f val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "},{"title":"Catching.catchNonFatalEitherT​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#catchingcatchnonfataleithert","content":"Catching.catchNonFatalEitherT provides a convenient way to use CanCatchto catch NonFatal Throwable from EitherT[F, A, B] and returns EitherT[F, A, B]. "},{"title":"How to Use​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#how-to-use-5","content":"IOFutureId import scalaz._ import scalaz.effect._ import effectie.scalaz.Catching._ val fa = catchNonFatalEitherT[IO]( EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)) )(identity) // fa: EitherT[IO, Throwable, Int] = EitherT( // run = scalaz.effect.IO$$anon$7@6b35951b // ) fa.run.unsafePerformIO() // res91: Throwable \\/ Int = -\\/( // a = java.lang.RuntimeException: Something's wrong! // ) Copy "},{"title":"Happy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#happy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@281f60f5 val result = fa.unsafePerformIO() // result: MyError \\/ Int = \\/-(b = 200) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result is 200 Copy "},{"title":"Unhappy Path Example​","type":1,"pageTitle":"CanCatch","url":"docs/scalaz-effect/can-catch#unhappy-path-example-5","content":"IOFutureId import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz._ import effectie.scalaz.Effectful._ import effectie.scalaz.Catching._ import effectie.scalaz.EitherTSupport._ sealed trait MyError object MyError { final case class NonFatalThrowable(throwable: Throwable) extends MyError case object DivideByZero extends MyError def nonFatalThrowable(throwable: Throwable): MyError = NonFatalThrowable(throwable) def divideByZero: MyError = DivideByZero } def divide100By(n: Int): MyError \\/ Int = if (n === 0) MyError.divideByZero.left[Int] else (100 / n).right[MyError] def doSomethingBad(n: Int): Int = if (n < 0) throw new IllegalArgumentException(s\"n cannot be a negative number. [n: $n]\") else n * 2 def doSomething[F[_]: Fx: CanCatch: Monad]( n: Int ): F[MyError \\/ Int] = catchNonFatalEitherT( for { b <- EitherT(pureOf(divide100By(n))) c <- eitherTRight[MyError](doSomethingBad(b)) } yield c )(MyError.nonFatalThrowable).run val fa = doSomething[IO](-1) // fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@3afc8316 val result = fa.unsafePerformIO() // result: MyError \\/ Int = -\\/( // a = NonFatalThrowable( // throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100] // ) // ) result match { case \\/-(b) => println(s\"Result is $b\") case -\\/(a) => println(s\"Result: Failed with $a\") } // Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]) Copy "}]