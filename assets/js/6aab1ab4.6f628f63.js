"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6353],{5537:(e,n,t)=>{t.d(n,{A:()=>w});var a=t(6540),r=t(4164),o=t(5627),i=t(6347),l=t(372),c=t(604),s=t(1861),d=t(8749);function h(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a}))}(t);return function(e){const n=(0,s.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function f({value:e,tabValues:n}){return n.some(n=>n.value===e)}function x({queryString:e=!1,groupId:n}){const t=(0,i.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=u(e),[i,c]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!f({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:o})),[s,h]=x({queryString:t,groupId:r}),[p,m]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,d.Dv)(n);return[t,(0,a.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),E=(()=>{const e=s??p;return f({value:e,tabValues:o})?e:null})();(0,l.A)(()=>{E&&c(E)},[E]);return{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!f({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),m(e)},[h,m,o]),tabValues:o}}var m=t(9136);const E={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(4848);function b({className:e,block:n,selectedValue:t,selectValue:a,tabValues:i}){const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),s=e=>{const n=e.currentTarget,r=l.indexOf(n),o=i[r].value;o!==t&&(c(n),a(o))},d=e=>{let n=null;switch(e.key){case"Enter":s(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:a})=>(0,y.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:s,...a,className:(0,r.A)("tabs__item",E.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:t}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:o.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function g(e){const n=p(e);return(0,y.jsxs)("div",{className:(0,r.A)("tabs-container",E.tabList),children:[(0,y.jsx)(b,{...n,...e}),(0,y.jsx)(v,{...n,...e})]})}function w(e){const n=(0,m.A)();return(0,y.jsx)(g,{...e,children:h(e.children)},String(n))}},6030:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>f,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"cats-effect3/fx/error-handling/can-catch","title":"CanCatch","description":"CanCatch","source":"@site/../generated-docs/docs/cats-effect3/fx/error-handling/can-catch.md","sourceDirName":"cats-effect3/fx/error-handling","slug":"/cats-effect3/fx/error-handling/can-catch","permalink":"/docs/cats-effect3/fx/error-handling/can-catch","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"id":"can-catch","title":"CanCatch"},"sidebar":"latestSidebar","previous":{"title":"Error Handling","permalink":"/docs/cats-effect3/fx/error-handling/"},"next":{"title":"CanHandleError","permalink":"/docs/cats-effect3/fx/error-handling/can-handle-error"}}');var r=t(4848),o=t(8453),i=t(5537),l=t(9329);const c={sidebar_position:1,id:"can-catch",title:"CanCatch"},s=void 0,d={},h=[{value:"CanCatch",id:"cancatch",level:2},{value:"CanCatch.catchNonFatal",id:"cancatchcatchnonfatal",level:2},{value:"How to Use",id:"how-to-use",level:3},{value:"Happy Path Example",id:"happy-path-example",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example",level:3},{value:"CanCatch.catchNonFatalEither",id:"cancatchcatchnonfataleither",level:2},{value:"How to Use",id:"how-to-use-1",level:3},{value:"Happy Path Example",id:"happy-path-example-1",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-1",level:3},{value:"CanCatch.catchNonFatalEitherT",id:"cancatchcatchnonfataleithert",level:2},{value:"How to Use",id:"how-to-use-2",level:3},{value:"Happy Path Example",id:"happy-path-example-2",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-2",level:3},{value:"Catching",id:"catching",level:2},{value:"Catching.catchNonFatal",id:"catchingcatchnonfatal",level:2},{value:"How to Use",id:"how-to-use-3",level:3},{value:"Happy Path Example",id:"happy-path-example-3",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-3",level:3},{value:"Catching.catchNonFatalEither",id:"catchingcatchnonfataleither",level:2},{value:"How to Use",id:"how-to-use-4",level:3},{value:"Happy Path Example",id:"happy-path-example-4",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-4",level:3},{value:"Catching.catchNonFatalEitherT",id:"catchingcatchnonfataleithert",level:2},{value:"How to Use",id:"how-to-use-5",level:3},{value:"Happy Path Example",id:"happy-path-example-5",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-5",level:3}];function u(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"cancatch",children:"CanCatch"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CanCatch"})," lets you catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," in the ",(0,r.jsx)(n.code,{children:"F[A]"}),"\nand turned it into ",(0,r.jsx)(n.code,{children:"F[Either[Throwable, A]]"}),". It takes a function from ",(0,r.jsx)(n.code,{children:"Throwable"}),"\nto your own error type, yet it can handle only ",(0,r.jsx)(n.code,{children:"NonFatal"})," ones as already mentioned."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CanCatch"})," looks like this."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"trait CanCatch[F[_]] {\n  def catchNonFatal[A, B](fb: => F[B])(f: PartialFunction[Throwable, A]): F[Either[A, B]]\n\n  def catchNonFatalEither[A, AA >: A, B](fab: => F[Either[A, B]])(\n    f: PartialFunction[Throwable, AA]\n  ): F[Either[AA, B]]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In practice, you don't need to use it directly because ",(0,r.jsx)(n.code,{children:"Fx"})," is already ",(0,r.jsx)(n.code,{children:"CanCatch"})," as well."]}),"\n",(0,r.jsx)(n.h2,{id:"cancatchcatchnonfatal",children:"CanCatch.catchNonFatal"}),"\n",(0,r.jsxs)(i.A,{groupId:"can-catch",defaultValue:"fx",values:[{label:"Fx",value:"fx"},{label:"CanCatch",value:"cancatch"}],children:[(0,r.jsx)(l.A,{value:"fx",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val fa: F[A] = ...\nFx[F].catchNonFatal(fa) {\n  case SomeException(message) =>\n    SomeError(message)\n} // F[Either[SomeError, A]\n"})})}),(0,r.jsx)(l.A,{value:"cancatch",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"val fa: F[A] = ...\nCanCatch[F].catchNonFatal(fa) {\n  case SomeException(message) =>\n    SomeError(message)\n} // F[Either[SomeError, A]\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CanCatch[F].catchNonFatal[A, B]"})," lets you catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"F[B]"}),"\nand returns ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\n\nimport effectie.core._\nimport effectie.instances.ce3.fx.ioFx\n\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nCanCatch[IO].catchNonFatal(\n    IO(throw new RuntimeException("Something\'s wrong!"))\n  ) {\n    case ex =>\n      MyException(ex)\n  }\n// res1: IO[Either[MyException, Nothing]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = Delay(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.core._\nimport effectie.instances.future.fx.futureFx\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@205e0711[Running, parallelism = 4, size = 2, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@2e3787b1\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nval fa = CanCatch[Future].catchNonFatal(\n    Future(throw new RuntimeException(\"Something's wrong!\"))\n  ) {\n    case ex =>\n      MyException(ex)\n  }\n// fa: Future[Either[MyException, Nothing]] = Future(Success(Left(repl.MdocSession$App2$MyException)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res3: Either[MyException, Nothing] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import cats._\n\nimport effectie.core._\nimport effectie.instances.id.fx.idFx\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nCanCatch[Id].catchNonFatal(\n    throw new RuntimeException(\"Something's wrong!\")\n  ) {\n    case ex =>\n      MyException(ex)\n  }\n// res5: Id[Either[MyException, Nothing]] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// res7: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\n  def main(arg: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(202)\n// Result is 202\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 202)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-101)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// res13: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](-101)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-101)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"cancatchcatchnonfataleither",children:"CanCatch.catchNonFatalEither"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CanCatch[F].catchNonFatalEither[A, B]"})," lets you catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"}),"\nand returns ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use-1",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\n\nimport effectie.core._\nimport effectie.instances.ce3.fx.ioFx\n\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nCanCatch[IO].catchNonFatalEither(\n    IO((throw new RuntimeException("Something\'s wrong!")): Either[Throwable, Int])\n  ) {\n    case ex => MyException(ex)\n  }\n// res19: IO[Either[Throwable, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = Delay(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.core._\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@4990bd51[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@5b08a1dd\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.future.fx.futureFx\n\nval fa = CanCatch[Future].catchNonFatalEither(\n    Future((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])\n  ) {\n    case ex => MyException(ex)\n  }\n// fa: Future[Either[Throwable, Int]] = Future(Success(Left(repl.MdocSession$App20$MyException)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res21: Either[Throwable, Int] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import cats._\n\nimport effectie.core._\nimport effectie.instances.id.fx.idFx\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nCanCatch[Id].catchNonFatalEither(\n    (throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]\n  ){\n    case ex => MyException(ex)\n  }\n// res23: Id[Either[Throwable, Int]] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example-1",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res25: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n  \n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(200)\n// Result is 200\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 200)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example-1",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res31: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }\n  \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-1)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"cancatchcatchnonfataleithert",children:"CanCatch.catchNonFatalEitherT"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CanCatch[F].catchNonFatalEitherT[A, B]"})," lets you catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"EitherT[F, A, B]"}),"\nand returns ",(0,r.jsx)(n.code,{children:"EitherT[F, A, B]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use-2",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.data.EitherT\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport effectie.instances.ce3.fx.ioFx\n\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nCanCatch[IO].catchNonFatalEitherT(\n    EitherT(IO((throw new RuntimeException("Something\'s wrong!")): Either[Throwable, Int]))\n  ) {\n    case ex => MyException(ex)\n  }\n// res37: EitherT[[\u03b1$0$]IO[\u03b1$0$], Throwable, Int] = EitherT(\n//   value = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats.data.EitherT\nimport effectie.core._\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@1e73c3c5[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@35c146ef\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.syntax.all._\nimport effectie.instances.future.fx.futureFx\n\nval fa = CanCatch[Future].catchNonFatalEitherT(\n    EitherT(Future((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]))\n  ) {\n    case ex => MyException(ex)\n  }\n// fa: EitherT[[\u03b1$0$]Future[\u03b1$0$], Throwable, Int] = EitherT(\n//   value = Future(Success(Left(repl.MdocSession$App38$MyException)))\n// )\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa.value, Duration.Inf)\n// res39: Either[Throwable, Int] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import cats._\nimport cats.data.EitherT\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport effectie.instances.id.fx.idFx\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nval fa = CanCatch[Id].catchNonFatalEitherT(\n    EitherT((throw new RuntimeException(\"Something's wrong!\")): Id[Either[Throwable, Int]])\n  ) {\n    case ex => MyException(ex)\n  }\n// fa: EitherT[[\u03b1$0$]Id[\u03b1$0$], Throwable, Int] = EitherT(\n//   value = Left(\n//     value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// ...\n\nfa.value\n// res41: Id[Either[Throwable, Int]] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example-2",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- pureOf(divide100By(n)).eitherT\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }.value\n  \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res43: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatalEitherT(\n      for {\n        b <- pureOf(divide100By(n)).eitherT\n        c <- doSomethingBad(b).rightTF[F, MyError]\n      } yield c\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(200)\n// Result is 200\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- pureOf(divide100By(n)).eitherT\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }.value\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 200)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example-2",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- pureOf(divide100By(n)).eitherT\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }.value\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res49: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport extras.cats.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    CanCatch[F].catchNonFatalEitherT(\n      for {\n        b <- pureOf(divide100By(n)).eitherT\n        c <- doSomethingBad(b).rightTF[F, MyError]\n      } yield c\n    ) {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    import effectie.instances.future.fx.futureFx\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- pureOf(divide100By(n)).eitherT\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c\n  ) {\n    case ex => MyError.nonFatalThrowable(ex)\n  }.value\n  \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-1)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"catching",children:"Catching"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Catching.catchNonFatal"})," provides a convenient way to use ",(0,r.jsx)(n.code,{children:"CanCatch"})," to catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," in the ",(0,r.jsx)(n.code,{children:"F[A]"}),"\nand turned it into ",(0,r.jsx)(n.code,{children:"F[Either[Throwable, A]]"}),". Just like ",(0,r.jsx)(n.code,{children:"CanCatch"}),", it takes a function from ",(0,r.jsx)(n.code,{children:"Throwable"}),"\nto your own error type, yet it can handle only ",(0,r.jsx)(n.code,{children:"NonFatal"})," ones as already mentioned."]}),"\n",(0,r.jsx)(n.h2,{id:"catchingcatchnonfatal",children:"Catching.catchNonFatal"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"catchNonFatal"})," lets you catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"F[B]"}),"\nand returns ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use-3",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\n\nimport effectie.syntax.all._\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nIO(throw new RuntimeException("Something\'s wrong!"))\n  .catchNonFatal {\n    case ex => MyException(ex)\n  }\n// res55: IO[Either[MyException, Nothing]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = Delay(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.syntax.all._\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@6782d54a[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@58cb016b\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.future.fx.futureFx\n\nval fa = \n    Future(throw new RuntimeException(\"Something's wrong!\"))\n      .catchNonFatal {\n        case ex => MyException(ex)\n      }\n// fa: Future[Either[MyException, Nothing]] = Future(Success(Left(repl.MdocSession$App56$MyException)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res57: Either[MyException, Nothing] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example-3",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    a <- pureOf(n + 100)\n    b <- effectOf(doSomethingBad(a))\n  } yield b)\n    .catchNonFatal {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n    \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// res60: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b)\n      .catchNonFatal {\n        case ex => MyError.nonFatalThrowable(ex)\n      }\n\n  def main(arg: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      import effectie.instances.future.fx.futureFx\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(202)\n// Result is 202\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    a <- pureOf(n + 100)\n    b <- effectOf(doSomethingBad(a))\n  } yield b)\n    .catchNonFatal {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 202)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example-3",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    a <- pureOf(n + 100)\n    b <- effectOf(doSomethingBad(a))\n  } yield b)\n    .catchNonFatal {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-101)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// res66: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b)\n      .catchNonFatal {\n        case ex => MyError.nonFatalThrowable(ex)\n      }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      import effectie.instances.future.fx.futureFx\n      \n      val fa = doSomething[Future](-101)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    a <- pureOf(n + 100)\n    b <- effectOf(doSomethingBad(a))\n  } yield b)\n    .catchNonFatal {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-101)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"catchingcatchnonfataleither",children:"Catching.catchNonFatalEither"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Catching.catchNonFatalEither"})," provides a convenient way to use ",(0,r.jsx)(n.code,{children:"CanCatch"}),"\nto catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"})," and returns ",(0,r.jsx)(n.code,{children:"F[Either[A, B]]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use-4",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.effect._\n\nimport effectie.syntax.all._\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.ce3.fx.ioFx\n\nIO((throw new RuntimeException("Something\'s wrong!")): Either[Throwable, Int])\n  .catchNonFatalEither {\n    case ex => MyException(ex)\n  }\n// res72: IO[Either[Throwable, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = Delay(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.syntax.all._\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@198483c6[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@48a94e8\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.future.fx.futureFx\n\nval fa = \n  Future((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int])\n    .catchNonFatalEither {\n      case ex => MyException(ex)\n    }\n// fa: Future[Either[Throwable, Int]] = Future(Success(Left(repl.MdocSession$App73$MyException)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res74: Either[Throwable, Int] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example-4",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    aOrB <- pureOf(divide100By(n))\n    c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n  } yield c)\n    .catchNonFatalEither {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n    \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res77: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n  \n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c)\n      .catchNonFatalEither {\n        case ex => MyError.nonFatalThrowable(ex)\n      }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      import effectie.instances.future.fx.futureFx\n      \n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(200)\n// Result is 200\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    aOrB <- pureOf(divide100By(n))\n    c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n  } yield c)\n    .catchNonFatalEither {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 200)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example-4",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    aOrB <- pureOf(divide100By(n))\n    c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n  } yield c)\n    .catchNonFatalEither {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res83: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c)\n      .catchNonFatalEither {\n        case ex => MyError.nonFatalThrowable(ex)\n      }\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      import effectie.instances.future.fx.futureFx\n      \n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    aOrB <- pureOf(divide100By(n))\n    c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n  } yield c)\n    .catchNonFatalEither {\n      case ex => MyError.nonFatalThrowable(ex)\n    }\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-1)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"catchingcatchnonfataleithert",children:"Catching.catchNonFatalEitherT"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Catching.catchNonFatalEitherT"})," provides a convenient way to use ",(0,r.jsx)(n.code,{children:"CanCatch"}),"\nto catch ",(0,r.jsx)(n.code,{children:"NonFatal"})," ",(0,r.jsx)(n.code,{children:"Throwable"})," from ",(0,r.jsx)(n.code,{children:"EitherT[F, A, B]"})," and returns ",(0,r.jsx)(n.code,{children:"EitherT[F, A, B]"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"how-to-use-5",children:"How to Use"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats.data.EitherT\nimport cats.effect._\n\nimport effectie.syntax.all._\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.ce3.fx.ioFx\n\n\nEitherT(IO((throw new RuntimeException("Something\'s wrong!")): Either[Throwable, Int]))\n  .catchNonFatalEitherT {\n    case ex => MyException(ex)\n  }\n// res89: EitherT[[A]IO[A], Throwable, Int] = EitherT(\n//   value = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats.data.EitherT\n\nimport effectie.syntax.all._\n\nimplicit val executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@755329b6[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@7593be2e\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.future.fx.futureFx\n\nval fa = \n  EitherT(Future((throw new RuntimeException(\"Something's wrong!\")): Either[Throwable, Int]))\n    .catchNonFatalEitherT {\n      case ex => MyException(ex)\n    }\n// fa: EitherT[[T]Future[T], Throwable, Int] = EitherT(\n//   value = Future(Success(Left(repl.MdocSession$App90$MyException)))\n// )\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa.value, Duration.Inf)\n// res91: Either[Throwable, Int] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:"import cats._\nimport cats.data.EitherT\n\nimport effectie.syntax.all._\n\nfinal case class MyException(cause: Throwable) extends RuntimeException\n\nimport effectie.instances.id.fx.idFx\n\nval fa =\n  EitherT((throw new RuntimeException(\"Something's wrong!\")): Id[Either[Throwable, Int]])\n    .catchNonFatalEitherT {\n      case ex => MyException(ex)\n    }\n// fa: EitherT[[A]Id[A], Throwable, Int] = EitherT(\n//   value = Left(\n//     value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// ...\n\nfa.value\n// res93: Id[Either[Throwable, Int]] = Left(\n//   value = MyException(cause = java.lang.RuntimeException: Something's wrong!)\n// )\n"})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"happy-path-example-5",children:"Happy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.syntax.all._\nimport cats.data.EitherT\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    b <- EitherT(pureOf(divide100By(n)))\n    c <- doSomethingBad(b).rightTF[F, MyError]\n  } yield c)\n    .catchNonFatalEitherT {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n    \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res95: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.data.EitherT\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c)\n      .catchNonFatalEitherT {\n        case ex => MyError.nonFatalThrowable(ex)\n      }.value\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      import effectie.instances.future.fx.futureFx\n      \n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Right(200)\n// Result is 200\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.data.EitherT\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    b <- EitherT(pureOf(divide100By(n)))\n    c <- doSomethingBad(b).rightTF[F, MyError]\n  } yield c)\n    .catchNonFatalEitherT {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n\nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](1)\n// fa: Id[Either[MyError, Int]] = Right(value = 200)\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(n.h3,{id:"unhappy-path-example-5",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(i.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(l.A,{value:"io",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.data.EitherT\nimport cats.syntax.all._\nimport cats.effect._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    b <- EitherT(pureOf(divide100By(n)))\n    c <- doSomethingBad(b).rightTF[F, MyError]\n  } yield c)\n    .catchNonFatalEitherT {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n    \nimport effectie.instances.ce3.fx.ioFx\n\n\nval fa = doSomething[IO](-1)\n// fa: IO[Either[MyError, Int]] = FlatMap(\n//   ioe = Attempt(\n//     ioa = FlatMap(\n// ...\nfa.map {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// res101: IO[Unit] = Map(\n//   ioe = FlatMap(\n//     ioe = Attempt(\n// ...\n'})})}),(0,r.jsx)(l.A,{value:"future",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport cats._\nimport cats.data.EitherT\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\nimport extras.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): Either[MyError, Int] =\n    if (n === 0)\n      MyError.divideByZero.asLeft[Int]\n    else\n      (100 / n).asRight[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[Either[MyError, Int]] =\n    (for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- doSomethingBad(b).rightTF[F, MyError]\n    } yield c)\n      .catchNonFatalEitherT {\n        case ex => MyError.nonFatalThrowable(ex)\n      }.value\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      import effectie.instances.future.fx.futureFx\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case Right(b) =>\n          println(s"Result is $b")\n        case Left(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// Left(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(l.A,{value:"id",children:[(0,r.jsx)(n.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(n.p,{children:["Use of ",(0,r.jsx)(n.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(n.code,{children:"Id"})," means having no ",(0,r.jsx)(n.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scala",children:'import cats._\nimport cats.data.EitherT\nimport cats.syntax.all._\n\nimport effectie.core._\nimport effectie.syntax.all._\nimport extras.cats.syntax.all._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): Either[MyError, Int] =\n  if (n === 0)\n    MyError.divideByZero.asLeft[Int]\n  else\n    (100 / n).asRight[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[Either[MyError, Int]] =\n  (for {\n    b <- EitherT(pureOf(divide100By(n)))\n    c <- doSomethingBad(b).rightTF[F, MyError]\n  } yield c)\n    .catchNonFatalEitherT {\n      case ex => MyError.nonFatalThrowable(ex)\n    }.value\n    \nimport effectie.instances.id.fx.idFx\n\nval fa = doSomething[Id](-1)\n// fa: Id[Either[MyError, Int]] = Left(\n//   value = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative numbe...\nfa match {\n  case Right(b) =>\n    println(s"Result is $b")\n  case Left(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(6540);const r={},o=a.createContext(r);function i(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:n},e.children)}},9329:(e,n,t)=>{t.d(n,{A:()=>i});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var o=t(4848);function i({children:e,hidden:n,className:t}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,t),hidden:n,children:e})}}}]);