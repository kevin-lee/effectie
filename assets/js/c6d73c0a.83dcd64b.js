"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7232],{5537:(n,e,a)=>{a.d(e,{A:()=>w});var t=a(6540),r=a(4164),o=a(5627),l=a(6347),i=a(372),c=a(604),s=a(1861),d=a(8749);function h(n){return t.Children.toArray(n).filter(n=>"\n"!==n).map(n=>{if(!n||(0,t.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(n){const{values:e,children:a}=n;return(0,t.useMemo)(()=>{const n=e??function(n){return h(n).map(({props:{value:n,label:e,attributes:a,default:t}})=>({value:n,label:e,attributes:a,default:t}))}(a);return function(n){const e=(0,s.XI)(n,(n,e)=>n.value===e.value);if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map(n=>n.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n},[e,a])}function f({value:n,tabValues:e}){return e.some(e=>e.value===n)}function m({queryString:n=!1,groupId:e}){const a=(0,l.W6)(),r=function({queryString:n=!1,groupId:e}){if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,c.aZ)(r),(0,t.useCallback)(n=>{if(!r)return;const e=new URLSearchParams(a.location.search);e.set(r,n),a.replace({...a.location,search:e.toString()})},[r,a])]}function p(n){const{defaultValue:e,queryString:a=!1,groupId:r}=n,o=u(n),[l,c]=(0,t.useState)(()=>function({defaultValue:n,tabValues:e}){if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!f({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map(n=>n.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=e.find(n=>n.default)??e[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:e,tabValues:o})),[s,h]=m({queryString:a,groupId:r}),[p,b]=function({groupId:n}){const e=function(n){return n?`docusaurus.tab.${n}`:null}(n),[a,r]=(0,d.Dv)(e);return[a,(0,t.useCallback)(n=>{e&&r.set(n)},[e,r])]}({groupId:r}),x=(()=>{const n=s??p;return f({value:n,tabValues:o})?n:null})();(0,i.A)(()=>{x&&c(x)},[x]);return{selectedValue:l,selectValue:(0,t.useCallback)(n=>{if(!f({value:n,tabValues:o}))throw new Error(`Can't select invalid tab value=${n}`);c(n),h(n),b(n)},[h,b,o]),tabValues:o}}var b=a(9136);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var E=a(4848);function g({className:n,block:e,selectedValue:a,selectValue:t,tabValues:l}){const i=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),s=n=>{const e=n.currentTarget,r=i.indexOf(e),o=l[r].value;o!==a&&(c(e),t(o))},d=n=>{let e=null;switch(n.key){case"Enter":s(n);break;case"ArrowRight":{const a=i.indexOf(n.currentTarget)+1;e=i[a]??i[0];break}case"ArrowLeft":{const a=i.indexOf(n.currentTarget)-1;e=i[a]??i[i.length-1];break}}e?.focus()};return(0,E.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":e},n),children:l.map(({value:n,label:e,attributes:t})=>(0,E.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:n=>{i.push(n)},onKeyDown:d,onClick:s,...t,className:(0,r.A)("tabs__item",x.tabItem,t?.className,{"tabs__item--active":a===n}),children:e??n},n))})}function v({lazy:n,children:e,selectedValue:a}){const o=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const n=o.find(n=>n.props.value===a);return n?(0,t.cloneElement)(n,{className:(0,r.A)("margin-top--md",n.props.className)}):null}return(0,E.jsx)("div",{className:"margin-top--md",children:o.map((n,e)=>(0,t.cloneElement)(n,{key:e,hidden:n.props.value!==a}))})}function y(n){const e=p(n);return(0,E.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,E.jsx)(g,{...e,...n}),(0,E.jsx)(v,{...e,...n})]})}function w(n){const e=(0,b.A)();return(0,E.jsx)(y,{...n,children:h(n.children)},String(e))}},8146:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>f,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"docs/scalaz-effect/can-catch","title":"CanCatch","description":"CanCatch","source":"@site/versioned_docs/version-v1/docs/scalaz-effect/can-catch.md","sourceDirName":"docs/scalaz-effect","slug":"/docs/scalaz-effect/can-catch","permalink":"/docs/v1/docs/scalaz-effect/can-catch","draft":false,"unlisted":false,"tags":[],"version":"v1","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"id":"can-catch","title":"CanCatch"},"sidebar":"sidebar","previous":{"title":"Fx","permalink":"/docs/v1/docs/scalaz-effect/fx"},"next":{"title":"OptionTSupport","permalink":"/docs/v1/docs/scalaz-effect/optiont-support"}}');var r=a(4848),o=a(8453),l=a(5537),i=a(9329);const c={sidebar_position:2,id:"can-catch",title:"CanCatch"},s=void 0,d={},h=[{value:"CanCatch",id:"cancatch",level:2},{value:"CanCatch.catchNonFatal",id:"cancatchcatchnonfatal",level:2},{value:"How to Use",id:"how-to-use",level:3},{value:"Happy Path Example",id:"happy-path-example",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example",level:3},{value:"CanCatch.catchNonFatalEither",id:"cancatchcatchnonfataleither",level:2},{value:"How to Use",id:"how-to-use-1",level:3},{value:"Happy Path Example",id:"happy-path-example-1",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-1",level:3},{value:"CanCatch.catchNonFatalEitherT",id:"cancatchcatchnonfataleithert",level:2},{value:"How to Use",id:"how-to-use-2",level:3},{value:"Happy Path Example",id:"happy-path-example-2",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-2",level:3},{value:"Catching",id:"catching",level:2},{value:"Catching.catchNonFatal",id:"catchingcatchnonfatal",level:2},{value:"How to Use",id:"how-to-use-3",level:3},{value:"Happy Path Example",id:"happy-path-example-3",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-3",level:3},{value:"Catching.catchNonFatalEither",id:"catchingcatchnonfataleither",level:2},{value:"How to Use",id:"how-to-use-4",level:3},{value:"Happy Path Example",id:"happy-path-example-4",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-4",level:3},{value:"Catching.catchNonFatalEitherT",id:"catchingcatchnonfataleithert",level:2},{value:"How to Use",id:"how-to-use-5",level:3},{value:"Happy Path Example",id:"happy-path-example-5",level:3},{value:"Unhappy Path Example",id:"unhappy-path-example-5",level:3}];function u(n){const e={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"cancatch",children:"CanCatch"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"CanCatch"})," lets you catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," in the ",(0,r.jsx)(e.code,{children:"F[A]"}),"\nand turned it into ",(0,r.jsx)(e.code,{children:"F[Either[Throwable, A]]"}),". It takes a function from ",(0,r.jsx)(e.code,{children:"Throwable"}),"\nto your own error type, yet it can handle only ",(0,r.jsx)(e.code,{children:"NonFatal"})," ones as already mentioned."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"trait CanCatch[F[_]] {\n  def catchNonFatal[A, B](fb: => F[B])(f: Throwable => A): F[A \\/ B]\n\n  def catchNonFatalEither[A, B](fab: => F[A \\/ B])(f: Throwable => A): F[A \\/ B]\n\n  def catchNonFatalEitherT[A, B](fab: => EitherT[F, A, B])(f: Throwable => A): EitherT[F, A, B]\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"cancatchcatchnonfatal",children:"CanCatch.catchNonFatal"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"CanCatch[F].catchNonFatal[A, B]"})," lets you catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"F[B]"}),"\nand returns ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz.effect._\n\nimport effectie.scalaz._\n\nval fa = CanCatch[IO].catchNonFatal(\n    IO(throw new RuntimeException(\"Something's wrong!\"))\n  )(identity)\n// fa: IO[scalaz.\\/[Throwable, Nothing]] = scalaz.effect.IO$$anon$7@1d06c0e5\n\nfa.unsafePerformIO()\n// res1: scalaz.\\/[Throwable, Nothing] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.scalaz._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@1885bef0[Running, parallelism = 4, size = 2, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@2e22e6d1\n\nval fa = CanCatch[Future].catchNonFatal(\n    Future(throw new RuntimeException(\"Something's wrong!\"))\n  )(identity)\n// fa: Future[scalaz.\\/[Throwable, Nothing]] = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res3: scalaz.\\/[Throwable, Nothing] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\n\nCanCatch[Id].catchNonFatal(\n    throw new RuntimeException(\"Something's wrong!\")\n  )(identity)\n// res5: Throwable \\/ Nothing = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2a010c97\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 202)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    )(MyError.nonFatalThrowable)\n\n  def main(arg: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(202)\n// Result is 202\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 202)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](-101)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@12bf0da\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      val fa = doSomething[Future](-101)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](-101)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})]})]}),"\n",(0,r.jsx)(e.h2,{id:"cancatchcatchnonfataleither",children:"CanCatch.catchNonFatalEither"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"CanCatch[F].catchNonFatalEither[A, B]"})," lets you catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"}),"\nand returns ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use-1",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\n\nval fa = CanCatch[IO].catchNonFatalEither(\n    IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)\n  )(identity)\n// fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@346cac31\n\nfa.unsafePerformIO()\n// res19: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\n\nimport effectie.scalaz._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@dc1c003[Running, parallelism = 4, size = 4, active = 0, running = 0, steals = 3, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@2f061098\n\nval fa = CanCatch[Future].catchNonFatalEither(\n    Future((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)\n  )(identity)\n// fa: Future[Throwable \\/ Int] = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res21: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\n\nCanCatch[Id].catchNonFatalEither(\n    (throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int\n  )(identity)\n// res23: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example-1",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@71758882\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 200)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n  \n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(200)\n// Result is 200\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 200)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example-1",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](-1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@20a9afb9\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](-1)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(e.h2,{id:"cancatchcatchnonfataleithert",children:"CanCatch.catchNonFatalEitherT"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"CanCatch[F].catchNonFatalEitherT[A, B]"})," lets you catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"EitherT[F, A, B]"}),"\nand returns ",(0,r.jsx)(e.code,{children:"EitherT[F, A, B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use-2",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\n\nval fa = CanCatch[IO].catchNonFatalEitherT(\n    EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int))\n  )(identity)\n// fa: EitherT[IO, Throwable, Int] = EitherT(\n//   run = scalaz.effect.IO$$anon$7@236ba277\n// )\n\nfa.run.unsafePerformIO()\n// res37: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport effectie.scalaz._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@3c76e452[Running, parallelism = 4, size = 4, active = 0, running = 0, steals = 3, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@619a4ac6\n\nval fa = CanCatch[Future].catchNonFatalEitherT(\n    EitherT(Future((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int))\n  )(identity)\n// fa: EitherT[Future, Throwable, Int] = EitherT(\n//   run = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n// )\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa.run, Duration.Inf)\n// res39: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\n\nval fa = CanCatch[Id].catchNonFatalEitherT(\n    EitherT((throw new RuntimeException(\"Something's wrong!\")): Id[Throwable \\/ Int])\n  )(identity)\n// fa: EitherT[Id, Throwable, Int] = EitherT(\n//   run = -\\/(a = java.lang.RuntimeException: Something's wrong!)\n// )\n\nfa.run\n// res41: Id[Throwable \\/ Int] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example-2",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@ca3e52b\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 200)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.EitherTSupport._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatalEitherT(\n      for {\n        b <- EitherT(pureOf(divide100By(n)))\n        c <- eitherTRight[MyError](doSomethingBad(b))\n      } yield c\n    )(MyError.nonFatalThrowable).run\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(200)\n// Result is 200\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 200)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example-2",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.EitherTSupport._\nimport effectie.scalaz.Effectful._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[IO](-1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@722586d2\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.EitherTSupport._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    CanCatch[F].catchNonFatalEitherT(\n      for {\n        b <- EitherT(pureOf(divide100By(n)))\n        c <- eitherTRight[MyError](doSomethingBad(b))\n      } yield c\n    )(MyError.nonFatalThrowable).run\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  CanCatch[F].catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[Id](-1)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(e.h2,{id:"catching",children:"Catching"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Catching.catchNonFatal"})," provides a convenient way to use ",(0,r.jsx)(e.code,{children:"CanCatch"})," to catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," in the ",(0,r.jsx)(e.code,{children:"F[A]"}),"\nand turned it into ",(0,r.jsx)(e.code,{children:"F[Either[Throwable, A]]"}),". Just like ",(0,r.jsx)(e.code,{children:"CanCatch"}),", it takes a function from ",(0,r.jsx)(e.code,{children:"Throwable"}),"\nto your own error type, yet it can handle only ",(0,r.jsx)(e.code,{children:"NonFatal"})," ones as already mentioned."]}),"\n",(0,r.jsx)(e.h2,{id:"catchingcatchnonfatal",children:"Catching.catchNonFatal"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"catchNonFatal"})," lets you catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"F[B]"}),"\nand returns ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use-3",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz.effect._\n\nimport effectie.scalaz.Catching._\n\nval fa = catchNonFatal(\n    IO((throw new RuntimeException(\"Something's wrong!\")): Int)\n  )(identity)\n// fa: IO[scalaz.\\/[Throwable, Int]] = scalaz.effect.IO$$anon$7@79fab8b0\n\nfa.unsafePerformIO()\n// res55: scalaz.\\/[Throwable, Int] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport effectie.scalaz.Catching._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@4a050133[Running, parallelism = 4, size = 3, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@599c3fe5\n\nval fa = catchNonFatal(\n    Future(throw new RuntimeException(\"Something's wrong!\"))\n  )(identity)\n// fa: Future[scalaz.\\/[Throwable, Nothing]] = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res57: scalaz.\\/[Throwable, Nothing] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz.Catching._\n\ncatchNonFatal[Id](\n    throw new RuntimeException(\"Something's wrong!\")\n  )(identity)\n// res59: Id[Throwable \\/ Nothing] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example-3",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@7513112\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 202)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    )(MyError.nonFatalThrowable)\n\n  def main(arg: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(202)\n// Result is 202\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 202)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 202\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example-3",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](-101)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@2bc22670\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  }\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatal(\n      for {\n        a <- pureOf(n + 100)\n        b <- effectOf(doSomethingBad(a))\n      } yield b\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      val fa = doSomething[Future](-101)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n}\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatal(\n    for {\n      a <- pureOf(n + 100)\n      b <- effectOf(doSomethingBad(a))\n    } yield b\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](-101)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(MyError.NonFatalThrowable(a)) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with java.lang.IllegalArgumentException: n cannot be a negative number. [n: -1]\n'})})]})]}),"\n",(0,r.jsx)(e.h2,{id:"catchingcatchnonfataleither",children:"Catching.catchNonFatalEither"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Catching.catchNonFatalEither"})," provides a convenient way to use ",(0,r.jsx)(e.code,{children:"CanCatch"}),"\nto catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"})," and returns ",(0,r.jsx)(e.code,{children:"F[A \\/ B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use-4",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz.Catching._\n\nval fa = catchNonFatalEither(\n    IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)\n  )(identity)\n// fa: IO[Throwable \\/ Int] = scalaz.effect.IO$$anon$7@49acb6a2\n\nfa.unsafePerformIO()\n// res73: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\n\nimport effectie.scalaz.Catching._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@7177cb65[Running, parallelism = 4, size = 4, active = 0, running = 0, steals = 3, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@7fa0adf8\n\nval fa = catchNonFatalEither(\n    Future((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int)\n  )(identity)\n// fa: Future[Throwable \\/ Int] = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa, Duration.Inf)\n// res75: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz.Catching._\n\ncatchNonFatalEither[Id](\n    (throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int\n  )(identity)\n// res77: Id[Throwable \\/ Int] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example-4",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@456be5da\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 200)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n\n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n  \n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n\n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(200)\n// Result is 200\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 200)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example-4",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[IO](-1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@695e4273\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatalEither(\n      for {\n        aOrB <- pureOf(divide100By(n))\n        c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n      } yield c\n    )(MyError.nonFatalThrowable)\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEither(\n    for {\n      aOrB <- pureOf(divide100By(n))\n      c <- effectOf(aOrB.map(b => doSomethingBad(b)))\n    } yield c\n  )(MyError.nonFatalThrowable)\n\nval fa = doSomething[Id](-1)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]}),"\n",(0,r.jsx)(e.h2,{id:"catchingcatchnonfataleithert",children:"Catching.catchNonFatalEitherT"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Catching.catchNonFatalEitherT"})," provides a convenient way to use ",(0,r.jsx)(e.code,{children:"CanCatch"}),"\nto catch ",(0,r.jsx)(e.code,{children:"NonFatal"})," ",(0,r.jsx)(e.code,{children:"Throwable"})," from ",(0,r.jsx)(e.code,{children:"EitherT[F, A, B]"})," and returns ",(0,r.jsx)(e.code,{children:"EitherT[F, A, B]"}),"."]}),"\n",(0,r.jsx)(e.h3,{id:"how-to-use-5",children:"How to Use"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz.Catching._\n\nval fa = catchNonFatalEitherT[IO](\n    EitherT(IO((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int))\n  )(identity)\n// fa: EitherT[IO, Throwable, Int] = EitherT(\n//   run = scalaz.effect.IO$$anon$7@263d90de\n// )\n\nfa.run.unsafePerformIO()\n// res91: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\n\nimport effectie.scalaz.Catching._\n\nval executorService: ExecutorService = Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n// executorService: ExecutorService = java.util.concurrent.ForkJoinPool@5c08268c[Running, parallelism = 4, size = 4, active = 0, running = 0, steals = 3, tasks = 0, submissions = 0]\nimplicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n// ec: ExecutionContext = scala.concurrent.impl.ExecutionContextImpl$$anon$4@46d75de2\n\nval fa = catchNonFatalEitherT[Future](\n    EitherT(Future((throw new RuntimeException(\"Something's wrong!\")): Throwable \\/ Int))\n  )(identity)\n// fa: EitherT[Future, Throwable, Int] = EitherT(\n//   run = Future(Success(-\\/(java.lang.RuntimeException: Something's wrong!)))\n// )\n\n// Just for this example, you wouldn't want to do it in your production code\nAwait.result(fa.run, Duration.Inf)\n// res93: Throwable \\/ Int = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:"import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz.Catching._\n\nval fa = catchNonFatalEitherT[Id](\n    EitherT((throw new RuntimeException(\"Something's wrong!\")): Id[Throwable \\/ Int])\n  )(identity)\n// fa: EitherT[Id, Throwable, Int] = EitherT(\n//   run = -\\/(a = java.lang.RuntimeException: Something's wrong!)\n// )\n\nfa.run\n// res95: Id[Throwable \\/ Int] = -\\/(\n//   a = java.lang.RuntimeException: Something's wrong!\n// )\n"})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"happy-path-example-5",children:"Happy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[IO](1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@5d81d291\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = \\/-(b = 200)\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatalEitherT(\n      for {\n        b <- EitherT(pureOf(divide100By(n)))\n        c <- eitherTRight[MyError](doSomethingBad(b))\n      } yield c\n    )(MyError.nonFatalThrowable).run\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// \\/-(200)\n// Result is 200\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[Id](1)\n// fa: Id[MyError \\/ Int] = \\/-(b = 200)\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result is 200\n'})})]})]}),"\n",(0,r.jsx)(e.h3,{id:"unhappy-path-example-5",children:"Unhappy Path Example"}),"\n",(0,r.jsxs)(l.A,{groupId:"effects",defaultValue:"io",values:[{label:"IO",value:"io"},{label:"Future",value:"future"},{label:"Id",value:"id"}],children:[(0,r.jsx)(i.A,{value:"io",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\nimport scalaz.effect._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\nif (n < 0)\n  throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\nelse\n  n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[IO](-1)\n// fa: IO[MyError \\/ Int] = scalaz.effect.IO$$anon$7@1770129f\nval result = fa.unsafePerformIO()\n// result: MyError \\/ Int = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nresult match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsx)(i.A,{value:"future",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import java.util.concurrent.{ExecutorService, Executors}\nimport scala.concurrent.{ExecutionContext, Future, Await}\nimport scala.concurrent.duration._\n\nimport scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\nimport effectie.concurrent.ExecutorServiceOps\n\nobject MyApp {\n  sealed trait MyError\n  object MyError {\n    final case class NonFatalThrowable(throwable: Throwable) extends MyError\n    case object DivideByZero extends MyError\n    \n    def nonFatalThrowable(throwable: Throwable): MyError\n      = NonFatalThrowable(throwable)\n  \n    def divideByZero: MyError = DivideByZero\n  }\n\n  def divide100By(n: Int): MyError \\/ Int =\n    if (n === 0)\n      MyError.divideByZero.left[Int]\n    else\n      (100 / n).right[MyError]\n\n  def doSomethingBad(n: Int): Int =\n    if (n < 0)\n      throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n    else\n      n * 2\n\n  def doSomething[F[_]: Fx: CanCatch: Monad](\n    n: Int\n  ): F[MyError \\/ Int] =\n    catchNonFatalEitherT(\n      for {\n        b <- EitherT(pureOf(divide100By(n)))\n        c <- eitherTRight[MyError](doSomethingBad(b))\n      } yield c\n    )(MyError.nonFatalThrowable).run\n\n  def main(args: Array[String]): Unit = {\n    val executorService: ExecutorService =\n      Executors.newWorkStealingPool(Runtime.getRuntime.availableProcessors())\n    implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executorService)\n    \n    try {\n      val fa = doSomething[Future](-1)\n      println(fa)\n      val result = Await.result(fa, 1.second)\n      println(result)\n      result match {\n        case \\/-(b) =>\n          println(s"Result is $b")\n        case -\\/(a) =>\n          println(s"Result: Failed with $a")\n      }\n    } finally {\n      ExecutorServiceOps.shutdownAndAwaitTermination(executorService, 1.second)\n    }\n  }\n}\nMyApp.main(Array.empty)\n// Future(<not completed>)\n// -\\/(NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]))\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})}),(0,r.jsxs)(i.A,{value:"id",children:[(0,r.jsx)(e.admonition,{title:"NOTE",type:"caution",children:(0,r.jsxs)(e.p,{children:["Use of ",(0,r.jsx)(e.code,{children:"Id"})," is not recommended as ",(0,r.jsx)(e.code,{children:"Id"})," means having no ",(0,r.jsx)(e.code,{children:"Effect"}),". Use it only for some special cases like testing."]})}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-scala",children:'import scalaz._\nimport Scalaz._\n\nimport effectie.scalaz._\nimport effectie.scalaz.Effectful._\nimport effectie.scalaz.Catching._\nimport effectie.scalaz.EitherTSupport._\n\nsealed trait MyError\nobject MyError {\n  final case class NonFatalThrowable(throwable: Throwable) extends MyError\n  case object DivideByZero extends MyError\n  \n  def nonFatalThrowable(throwable: Throwable): MyError\n    = NonFatalThrowable(throwable)\n\n  def divideByZero: MyError = DivideByZero\n}\n\ndef divide100By(n: Int): MyError \\/ Int =\n  if (n === 0)\n    MyError.divideByZero.left[Int]\n  else\n    (100 / n).right[MyError]\n\ndef doSomethingBad(n: Int): Int =\n  if (n < 0)\n    throw new IllegalArgumentException(s"n cannot be a negative number. [n: $n]")\n  else\n    n * 2\n\ndef doSomething[F[_]: Fx: CanCatch: Monad](\n  n: Int\n): F[MyError \\/ Int] =\n  catchNonFatalEitherT(\n    for {\n      b <- EitherT(pureOf(divide100By(n)))\n      c <- eitherTRight[MyError](doSomethingBad(b))\n    } yield c\n  )(MyError.nonFatalThrowable).run\n\nval fa = doSomething[Id](-1)\n// fa: Id[MyError \\/ Int] = -\\/(\n//   a = NonFatalThrowable(\n//     throwable = java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100]\n//   )\n// )\nfa match {\n  case \\/-(b) =>\n    println(s"Result is $b")\n  case -\\/(a) =>\n    println(s"Result: Failed with $a")\n}\n// Result: Failed with NonFatalThrowable(java.lang.IllegalArgumentException: n cannot be a negative number. [n: -100])\n'})})]})]})]})}function f(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>l,x:()=>i});var t=a(6540);const r={},o=t.createContext(r);function l(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),t.createElement(o.Provider,{value:e},n.children)}},9329:(n,e,a)=>{a.d(e,{A:()=>l});a(6540);var t=a(4164);const r={tabItem:"tabItem_Ymn6"};var o=a(4848);function l({children:n,hidden:e,className:a}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,t.A)(r.tabItem,a),hidden:e,children:n})}}}]);